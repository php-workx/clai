# clai.zsh - clai shell integration for Zsh
# Generated by: clai init zsh
#
# Features:
#   1. Inline command suggestions (history + AI) with right-arrow to accept
#   2. Error diagnosis with `run` wrapper (captures output for analysis)
#   3. Voice mode with ` prefix (fast with Haiku daemon)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_EXTRACT=true    # Auto-extract commands (default: true)
#   CLAI_AUTO_DAEMON=true     # Auto-start daemon for fast voice (default: true)

# ============================================
# Configuration
# ============================================

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_AUTO_DAEMON:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Feature 1: Command Suggestion (History + AI)
# ============================================
# Shows inline ghost text suggestions as you type
# - While typing: matches against shell history
# - Empty buffer: shows AI suggestion if available
# - Right-arrow to accept

# Current suggestion state
_AI_CURRENT_SUGGESTION=""

# Update suggestion based on current buffer
_ai_update_suggestion() {
    local suggestion=""

    if [[ -z "$BUFFER" ]]; then
        # Empty buffer - check for AI suggestion
        suggestion=$(clai suggest 2>/dev/null)
    else
        # Has content - search history
        suggestion=$(clai suggest "$BUFFER" 2>/dev/null)
    fi

    _AI_CURRENT_SUGGESTION="$suggestion"

    # Show suggestion as ghost text after cursor
    if [[ -n "$suggestion" && "$suggestion" != "$BUFFER" ]]; then
        # Show only the part after what user typed
        if [[ -z "$BUFFER" ]]; then
            POSTDISPLAY="${suggestion}"
        else
            POSTDISPLAY="${suggestion#$BUFFER}"
        fi
    else
        POSTDISPLAY=""
    fi
}

# ZLE widget: Update suggestion after each character
_ai_self_insert() {
    zle .self-insert
    _ai_update_suggestion
}
zle -N self-insert _ai_self_insert

# ZLE widget: Update suggestion after backspace
_ai_backward_delete_char() {
    zle .backward-delete-char
    _ai_update_suggestion
}
zle -N backward-delete-char _ai_backward_delete_char

# ZLE widget: Accept suggestion with right arrow
_ai_forward_char() {
    if [[ -n "$POSTDISPLAY" && $CURSOR -eq ${#BUFFER} ]]; then
        # At end of buffer with suggestion - accept it
        BUFFER="$_AI_CURRENT_SUGGESTION"
        CURSOR=${#BUFFER}
        POSTDISPLAY=""
        _AI_CURRENT_SUGGESTION=""
        # Clear AI suggestion file if we used it
        > "$_AI_SUGGEST_FILE"
    else
        # Normal forward char
        zle .forward-char
    fi
}
zle -N forward-char _ai_forward_char

# ZLE widget: Clear suggestion with Escape
_ai_clear_suggestion() {
    POSTDISPLAY=""
    _AI_CURRENT_SUGGESTION=""
    > "$_AI_SUGGEST_FILE"
    zle redisplay
}
zle -N _ai_clear_suggestion

# Note: Escape is bound later to _ai_cancel_voice_mode which calls _ai_clear_suggestion

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion
# This works with speech-to-text tools like Wispr Flow that use the same hotkey
#
# Use ` prefix for voice input (e.g., "`list all files")
# The ` prefix is intercepted by ZLE before shell evaluation

_AI_VOICE_MODE=false

# ZLE widget: Enter voice mode
_ai_enter_voice_mode() {
    _AI_VOICE_MODE=true
    POSTDISPLAY=" ðŸŽ¤ Voice mode"
    zle redisplay
}
zle -N _ai_enter_voice_mode

# ZLE widget: Execute with voice conversion if in voice mode or ` prefix
_ai_voice_accept_line() {
    # Check for ` prefix (voice input marker)
    # Intercepted by ZLE before shell evaluation, so backtick is safe
    if [[ "$BUFFER" == '`'* && ${#BUFFER} -gt 1 ]]; then
        local voice_input="${BUFFER#\`}"  # Remove the ` prefix
        voice_input="${voice_input## }"   # Remove leading space if any
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "ðŸŽ¤ Converting: $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi

    # Check for explicit voice mode
    if [[ "$_AI_VOICE_MODE" == "true" && -n "$BUFFER" ]]; then
        # Convert the buffer through voice command
        _AI_VOICE_MODE=false
        POSTDISPLAY=""
        local voice_input="$BUFFER"
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "ðŸŽ¤ Converting: $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi
    # Normal accept-line behavior
    _AI_VOICE_MODE=false
    zle accept-line
}
zle -N _ai_voice_accept_line

# ZLE widget: Cancel voice mode with Escape
_ai_cancel_voice_mode() {
    if [[ "$_AI_VOICE_MODE" == "true" ]]; then
        _AI_VOICE_MODE=false
    fi
    # Clear suggestions
    _ai_clear_suggestion
}
zle -N _ai_cancel_voice_mode

# Bind Enter to voice-aware accept
bindkey '^M' _ai_voice_accept_line    # Enter

# Bind Ctrl+V for voice mode (Cmd+Ctrl doesn't produce a terminal sequence)
# Users can rebind this or use their speech-to-text tool's hotkey
bindkey '^X^V' _ai_enter_voice_mode   # Ctrl+X Ctrl+V

# Override escape to also cancel voice mode
bindkey '^[' _ai_cancel_voice_mode    # Escape

# ============================================
# Feature 2: Prompt Update Hook
# ============================================

# Update suggestion after each command completes
_ai_precmd() {
    # Show AI suggestion if available (buffer will be empty)
    _ai_update_suggestion
}

# Register hooks
autoload -U add-zsh-hook
add-zsh-hook precmd _ai_precmd

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${pipestatus[1]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(fc -ln -1)}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(fc -ln -5 2>/dev/null | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}


# ============================================
# Daemon Management
# ============================================

# Start daemon in background for fast voice responses
_ai_ensure_daemon() {
    if [[ "$CLAI_AUTO_DAEMON" == "true" ]]; then
        # Check if daemon is running, start if not (silently in background)
        (clai daemon start >/dev/null 2>&1 &)
    fi
}

# Daemon control commands
ai-daemon() {
    case "$1" in
        start)
            clai daemon start
            ;;
        stop)
            clai daemon stop
            ;;
        status)
            clai daemon status
            ;;
        restart)
            clai daemon stop
            clai daemon start
            ;;
        *)
            echo "Usage: ai-daemon {start|stop|status|restart}"
            echo "  Manages the background Claude daemon for fast voice responses"
            ;;
    esac
}

# ============================================
# Startup
# ============================================

if [[ -o interactive ]]; then
    # Start daemon if enabled
    _ai_ensure_daemon

    echo -e "\033[2mðŸ¤– clai loaded. Commands: ai-fix, ai, voice, ai-daemon | \` prefix for voice mode\033[0m"
fi
