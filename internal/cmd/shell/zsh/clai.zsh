# clai.zsh - clai shell integration for Zsh
# Generated by: clai init zsh
#
# Features:
#   1. Session tracking (commands logged for context-aware suggestions)
#   2. Inline command suggestions (history + AI) with right-arrow to accept
#   3. Menu selection with â†“ arrow (up/down to navigate, Enter to select)
#   4. Error diagnosis with `run` wrapper (captures output for analysis)
#   5. Natural language â†’ command with ? prefix (e.g., "?list all files")
#
# Configuration (set these BEFORE sourcing):
#   CLAI_MENU_LIMIT=5         # Max suggestions in menu (default: 5)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=zsh

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
# This enables context-aware suggestions across commands
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# Command tracking state
_CLAI_COMMAND_ID=""
_CLAI_COMMAND_START_TIME=""
_CLAI_LAST_COMMAND=""

# ============================================
# Feature 1: Command Suggestion (History + AI)
# ============================================
# Shows inline ghost text suggestions as you type
# - While typing: matches against shell history
# - Empty buffer: shows AI suggestion if available
# - Right-arrow to accept

# Current suggestion state
_AI_CURRENT_SUGGESTION=""

# Update suggestion based on current buffer
_ai_update_suggestion() {
    local suggestion=""

    if [[ -z "$BUFFER" ]]; then
        # Empty buffer - check for cached AI suggestion
        suggestion=$(clai suggest 2>/dev/null)
    else
        # Has content - clai handles daemon vs history fallback
        suggestion=$(clai suggest "$BUFFER" 2>/dev/null)
    fi

    _AI_CURRENT_SUGGESTION="$suggestion"

    # Clear ghost text (we use right prompt now)
    POSTDISPLAY=""

    # Show suggestion in right prompt
    if [[ -n "$suggestion" && "$suggestion" != "$BUFFER" ]]; then
        local display_suggestion="$suggestion"
        local display_prefix="$BUFFER"
        local max_suggestion=40  # Max length for suggestion
        local max_prefix=10      # Max length for prefix display

        # Truncate long suggestions
        if [[ ${#display_suggestion} -gt $max_suggestion ]]; then
            display_suggestion="${display_suggestion:0:$max_suggestion}â€¦"
        fi

        if [[ -z "$BUFFER" ]]; then
            # No input yet - show full suggestion
            RPS1="%F{242}($display_suggestion)%f"
        else
            # Truncate long prefix to just "..."
            if [[ ${#display_prefix} -gt $max_prefix ]]; then
                display_prefix="â€¦"
            fi
            # Show (partial â†’ full) format
            RPS1="%F{242}($display_prefix â†’ $display_suggestion)%f"
        fi
    else
        RPS1=""
    fi

    # Force prompt redraw to show updated RPS1 (only when in ZLE context)
    [[ -n "$WIDGET" ]] && zle reset-prompt
}

# ZLE widget: Update suggestion after each character
_ai_self_insert() {
    zle .self-insert
    _ai_update_suggestion
}
zle -N self-insert _ai_self_insert

# ZLE widget: Update suggestion after backspace
_ai_backward_delete_char() {
    zle .backward-delete-char
    _ai_update_suggestion
}
zle -N backward-delete-char _ai_backward_delete_char

# ZLE widget: Accept suggestion with right arrow
_ai_forward_char() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} ]]; then
        # At end of buffer with suggestion - accept it
        BUFFER="$_AI_CURRENT_SUGGESTION"
        CURSOR=${#BUFFER}
        RPS1=""
        _AI_CURRENT_SUGGESTION=""
        # Clear AI suggestion file if we used it
        > "$_AI_SUGGEST_FILE"
        zle reset-prompt
    else
        # Normal forward char
        zle .forward-char
    fi
}
zle -N forward-char _ai_forward_char

# ZLE widget: Clear suggestion with Escape
_ai_clear_suggestion() {
    RPS1=""
    _AI_CURRENT_SUGGESTION=""
    > "$_AI_SUGGEST_FILE"
    zle reset-prompt
}
zle -N _ai_clear_suggestion

# Note: Escape is bound later to _ai_cancel_voice_mode which calls _ai_clear_suggestion

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion
# This works with speech-to-text tools like Wispr Flow that use the same hotkey
#
# Use ? prefix for natural language input (e.g., "?list all files")
# The ? prefix is intercepted by ZLE before shell evaluation

_AI_VOICE_MODE=false

# ZLE widget: Enter voice mode
_ai_enter_voice_mode() {
    _AI_VOICE_MODE=true
    POSTDISPLAY=" ðŸŽ¤ Voice mode"
    zle redisplay
}
zle -N _ai_enter_voice_mode

# ZLE widget: Execute with voice conversion if in voice mode or ? prefix
_ai_voice_accept_line() {
    # Check for ? prefix (natural language marker)
    # Intercepted by ZLE before shell evaluation
    if [[ "$BUFFER" == '?'* && ${#BUFFER} -gt 1 ]]; then
        local voice_input="${BUFFER#\?}"  # Remove the ? prefix
        voice_input="${voice_input## }"   # Remove leading space if any
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi

    # Check for explicit voice mode
    if [[ "$_AI_VOICE_MODE" == "true" && -n "$BUFFER" ]]; then
        # Convert the buffer through voice command
        _AI_VOICE_MODE=false
        POSTDISPLAY=""
        local voice_input="$BUFFER"
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi
    # Normal accept-line behavior
    _AI_VOICE_MODE=false
    zle accept-line
}
zle -N _ai_voice_accept_line

# Bind Enter to voice-aware accept
bindkey '^M' _ai_voice_accept_line    # Enter

# Bind Ctrl+V for voice mode (Cmd+Ctrl doesn't produce a terminal sequence)
# Users can rebind this or use their speech-to-text tool's hotkey
bindkey '^X^V' _ai_enter_voice_mode   # Ctrl+X Ctrl+V

# Override escape to also cancel voice mode
bindkey '^[' _ai_cancel_voice_mode    # Escape

# ============================================
# Feature 2: Command Logging Hooks
# ============================================

# Log command start (runs before each command)
_ai_preexec() {
    # Skip if no command
    [[ -z "$1" ]] && return

    # Generate unique command ID (use seconds + random for uniqueness)
    _CLAI_COMMAND_ID="${CLAI_SESSION_ID}-$(date +%s)-${RANDOM}"
    # Store start time in milliseconds (macOS date doesn't support %N)
    _CLAI_COMMAND_START_TIME=$(($(date +%s) * 1000))
    _CLAI_LAST_COMMAND="$1"

    # Fire and forget - log command start to daemon
    (clai-shim log-start \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --cwd="$PWD" \
        --command="$1" >/dev/null 2>&1 &)
}

# Log command end and update suggestion (runs after each command)
_ai_precmd() {
    local exit_code=$?

    # Log command completion if we have a pending command
    if [[ -n "$_CLAI_COMMAND_ID" ]]; then
        local end_time=$(($(date +%s) * 1000))
        local duration=$((end_time - _CLAI_COMMAND_START_TIME))

        # Fire and forget - log command end to daemon
        (clai-shim log-end \
            --session-id="$CLAI_SESSION_ID" \
            --command-id="$_CLAI_COMMAND_ID" \
            --exit-code="$exit_code" \
            --duration="$duration" >/dev/null 2>&1 &)

        # Clear command tracking state
        _CLAI_COMMAND_ID=""
        _CLAI_COMMAND_START_TIME=""
    fi

    # Show AI suggestion if available (buffer will be empty)
    _ai_update_suggestion
}

# Register hooks
autoload -U add-zsh-hook
add-zsh-hook preexec _ai_preexec
add-zsh-hook precmd _ai_precmd

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${pipestatus[1]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
# Note: In zsh, `history` is often aliased to `fc -l`. We must use the
# `function` keyword to prevent alias expansion during parsing (unalias
# runs at execution time, but aliases expand at parse time).
unalias history 2>/dev/null
function history {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to zsh's native history (fc -l)
        shift
        fc -l "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            echo "$output"
        else
            # Fall back to shell's native history
            fc -l "$@"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(fc -ln -1)}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(fc -ln -5 2>/dev/null | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}


# ============================================
# Feature 4: Menu Selection (â†“ or Ctrl+Space)
# ============================================
# Shows multiple suggestions in a selectable menu
# - Down arrow (when typing): Show suggestion menu
# - Ctrl+Space: Alternative way to show menu
# - Up/Down arrows: Navigate menu once open
# - Enter: Accept selection
# - Escape: Cancel

# Menu state
_AI_MENU_SUGGESTIONS=()
_AI_MENU_INDEX=0
_AI_MENU_ACTIVE=false

# Fetch suggestions and show menu
_ai_show_menu() {
    local prefix="$BUFFER"

    # Get multiple suggestions (clai handles daemon vs history fallback)
    local -a suggestions
    if [[ -n "$prefix" ]]; then
        suggestions=(${(f)"$(clai suggest --limit "$CLAI_MENU_LIMIT" "$prefix" 2>/dev/null)"})
    fi

    if [[ ${#suggestions} -eq 0 ]]; then
        zle -M "No suggestions for: $prefix"
        return
    fi

    # Store suggestions and activate menu
    _AI_MENU_SUGGESTIONS=("${suggestions[@]}")
    _AI_MENU_INDEX=0
    _AI_MENU_ACTIVE=true

    # Render the menu
    _ai_render_menu
}

# Render the current menu state
_ai_render_menu() {
    local menu_text=""
    local i=0

    for suggestion in "${_AI_MENU_SUGGESTIONS[@]}"; do
        if [[ $i -eq $_AI_MENU_INDEX ]]; then
            # Highlighted selection
            menu_text+=$'\n'" â†’ $suggestion"
        else
            menu_text+=$'\n'"   $suggestion"
        fi
        ((i++))
    done

    # Show menu below prompt
    zle -M "Suggestions (â†‘â†“ to navigate, Enter to select, Esc to cancel):$menu_text"
}

# Navigate menu up
_ai_menu_up() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        if [[ $_AI_MENU_INDEX -gt 0 ]]; then
            ((_AI_MENU_INDEX--))
        else
            # Wrap to bottom
            _AI_MENU_INDEX=$((${#_AI_MENU_SUGGESTIONS[@]} - 1))
        fi
        _ai_render_menu
    elif [[ -n "$BUFFER" ]]; then
        # Has input - show menu (symmetric with down arrow)
        _ai_show_menu
    else
        # Empty buffer - normal history navigation
        zle .up-line-or-history
    fi
}

# Navigate menu down (or open menu if typing)
_ai_menu_down() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        # Menu active - navigate down
        if [[ $_AI_MENU_INDEX -lt $((${#_AI_MENU_SUGGESTIONS[@]} - 1)) ]]; then
            ((_AI_MENU_INDEX++))
        else
            # Wrap to top
            _AI_MENU_INDEX=0
        fi
        _ai_render_menu
    elif [[ -n "$BUFFER" ]]; then
        # Has input - show menu (arrow down is safe to override here)
        _ai_show_menu
    else
        # Empty buffer - normal history navigation
        zle .down-line-or-history
    fi
}

# Accept menu selection
_ai_menu_accept() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        local selected="${_AI_MENU_SUGGESTIONS[$_AI_MENU_INDEX + 1]}"  # zsh arrays are 1-indexed
        BUFFER="$selected"
        CURSOR=${#BUFFER}
        _ai_menu_cancel
        zle redisplay
    else
        # Pass through to normal accept (voice-aware)
        _ai_voice_accept_line
    fi
}

# Cancel menu
_ai_menu_cancel() {
    _AI_MENU_ACTIVE=false
    _AI_MENU_SUGGESTIONS=()
    _AI_MENU_INDEX=0
    zle -M ""  # Clear message
}

# Register menu widgets
zle -N _ai_show_menu
zle -N _ai_menu_up
zle -N _ai_menu_down
zle -N _ai_menu_accept

# Bind Ctrl+Space to show menu
bindkey '^ ' _ai_show_menu

# Override up/down arrows when menu is active
bindkey '^[[A' _ai_menu_up     # Up arrow
bindkey '^[[B' _ai_menu_down   # Down arrow

# Override Enter when menu is active
bindkey '^M' _ai_menu_accept

# Cancel voice mode and/or menu with Escape
_ai_cancel_voice_mode() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        _ai_menu_cancel
        return
    fi
    if [[ "$_AI_VOICE_MODE" == "true" ]]; then
        _AI_VOICE_MODE=false
    fi
    # Clear suggestions
    _ai_clear_suggestion
}
zle -N _ai_cancel_voice_mode

# ============================================
# Daemon Management
# ============================================

# Daemon control commands (Claude daemon for fast voice, started lazily on first use)
ai-daemon() {
    case "$1" in
        start)
            clai daemon start
            ;;
        stop)
            clai daemon stop
            ;;
        status)
            clai daemon status
            ;;
        restart)
            clai daemon stop
            clai daemon start
            ;;
        *)
            echo "Usage: ai-daemon {start|stop|status|restart}"
            echo "  Manages the background Claude daemon for fast voice responses"
            ;;
    esac
}

# ============================================
# Startup
# ============================================

# Cleanup function for shell exit
_clai_cleanup() {
    # Notify daemon session is ending
    clai-shim session-end --session-id="$CLAI_SESSION_ID" >/dev/null 2>&1
}

if [[ -o interactive ]]; then
    # Notify daemon of new session (fire and forget)
    # Note: claid starts lazily via clai-shim -> ipc.NewClient() -> EnsureDaemon()
    (clai-shim session-start \
        --session-id="$CLAI_SESSION_ID" \
        --cwd="$PWD" \
        --shell=zsh >/dev/null 2>&1 &)

    trap '_clai_cleanup' EXIT HUP

    local short_id="${CLAI_SESSION_ID:0:8}"
    echo -e "\033[2mðŸ¤– clai [$short_id] â†‘â†“ history | â†’ accept | ?\"describe task\"\033[0m"
fi
