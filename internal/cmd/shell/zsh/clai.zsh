# clai.zsh - clai shell integration for Zsh
# Generated by: clai init zsh
#
# Features:
#   1. Session tracking (commands logged for context-aware suggestions)
#   2. Inline ghost text suggestions (history + AI) with right-arrow to accept
#   3. Suggestion picker (Tab) + history picker (â†‘) with menu navigation
#   4. Error diagnosis with `run` wrapper (captures output for analysis)
#   5. Natural language â†’ command with ? prefix (e.g., "?list all files")
#
# Configuration (set these BEFORE sourcing):
#   CLAI_MENU_LIMIT=5         # Max suggestions in menu (default: 5)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=zsh

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
# This enables context-aware suggestions across commands
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# Command tracking state
_CLAI_COMMAND_ID=""
_CLAI_COMMAND_START_TIME=""
_CLAI_LAST_COMMAND=""

# ============================================
# Feature 1: Command Suggestion (History + AI)
# ============================================
# Shows inline ghost text suggestions as you type
# - While typing: matches against shell history
# - Empty buffer: shows AI suggestion if available
# - Right-arrow to accept
# - Alt+Right to accept next token

# Current suggestion state
_AI_CURRENT_SUGGESTION=""
_AI_IN_PASTE=false

# Disable zsh-autosuggestions when clai is active
_CLAI_ZSH_AUTOSUGGEST_PRESENT=false
if (( ${+functions[_zsh_autosuggest_start]} )); then
    _CLAI_ZSH_AUTOSUGGEST_PRESENT=true
fi
_CLAI_ZSH_AUTOSUGGEST_ORIG="${ZSH_AUTOSUGGEST_DISABLE:-}"

_clai_zsh_autosuggest_disable() {
    if [[ "$_CLAI_ZSH_AUTOSUGGEST_PRESENT" == "true" ]]; then
        export ZSH_AUTOSUGGEST_DISABLE=1
    fi
}

_clai_zsh_autosuggest_restore() {
    if [[ "$_CLAI_ZSH_AUTOSUGGEST_PRESENT" == "true" ]]; then
        if [[ -n "$_CLAI_ZSH_AUTOSUGGEST_ORIG" ]]; then
            export ZSH_AUTOSUGGEST_DISABLE="$_CLAI_ZSH_AUTOSUGGEST_ORIG"
        else
            unset ZSH_AUTOSUGGEST_DISABLE
        fi
    fi
}

# Session-level disable flag
_clai_session_off() {
    [[ -f "$CLAI_CACHE/off" ]]
}

# Update suggestion based on current buffer
_ai_update_suggestion() {
    local suggestion=""

    # Hide ghost text when disabled, picker active, buffer empty, or cursor not at EOL
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off || [[ "$_CLAI_PICKER_ACTIVE" == "true" ]] || [[ -z "$BUFFER" ]] || [[ $CURSOR -ne ${#BUFFER} ]]; then
        _clai_zsh_autosuggest_restore
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        region_highlight=()
        return
    fi

    _clai_zsh_autosuggest_disable
    # Has content - clai handles daemon vs history fallback
    suggestion=$(clai suggest "$BUFFER" 2>/dev/null)

    if [[ -n "$suggestion" && "$suggestion" != "$BUFFER" && "$suggestion" == "$BUFFER"* ]]; then
        _AI_CURRENT_SUGGESTION="$suggestion"
        local ghost="${suggestion:${#BUFFER}}"
        POSTDISPLAY="${ghost}"
        # region_highlight colors POSTDISPLAY; positions past ${#BUFFER} target it
        region_highlight=("${#BUFFER} $((${#BUFFER} + ${#ghost})) fg=242")
    else
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        region_highlight=()
    fi

    [[ -n "$WIDGET" ]] && zle reset-prompt
}

# ZLE widget: Update suggestion after each character
_ai_self_insert() {
    _clai_dismiss_picker
    zle .self-insert
    if [[ "$_AI_IN_PASTE" == "true" ]]; then
        return
    fi
    _ai_update_suggestion
}
zle -N self-insert _ai_self_insert

# Dismiss picker if active (called by editing/movement widgets).
# Uses _clai_picker_close (defined in picker section) via forward reference;
# safe because widgets are only invoked after full script is sourced.
_clai_dismiss_picker() {
    [[ "$_CLAI_PICKER_ACTIVE" == "true" ]] && _clai_picker_close
}

# ZLE widget: Update suggestion after backspace
_ai_backward_delete_char() {
    _clai_dismiss_picker
    zle .backward-delete-char
    _ai_update_suggestion
}
zle -N backward-delete-char _ai_backward_delete_char

# ZLE widget: Update suggestion after cursor movement
_ai_backward_char() {
    _clai_dismiss_picker
    zle .backward-char
    _ai_update_suggestion
}
zle -N backward-char _ai_backward_char

_ai_beginning_of_line() {
    _clai_dismiss_picker
    zle .beginning-of-line
    _ai_update_suggestion
}
zle -N beginning-of-line _ai_beginning_of_line

_ai_end_of_line() {
    _clai_dismiss_picker
    zle .end-of-line
    _ai_update_suggestion
}
zle -N end-of-line _ai_end_of_line

# ZLE widget: Handle bracketed paste as a single update
_ai_bracketed_paste() {
    _clai_dismiss_picker
    _AI_IN_PASTE=true
    zle .bracketed-paste
    _AI_IN_PASTE=false
    _ai_update_suggestion
}
zle -N bracketed-paste _ai_bracketed_paste

# ZLE widget: Accept suggestion with right arrow
_ai_forward_char() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} && "$_AI_CURRENT_SUGGESTION" == "$BUFFER"* ]]; then
        # At end of buffer with valid suggestion prefix - accept it
        BUFFER="$_AI_CURRENT_SUGGESTION"
        CURSOR=${#BUFFER}
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        region_highlight=()
        # Clear AI suggestion file if we used it
        > "$_AI_SUGGEST_FILE"
        zle reset-prompt
    else
        # Normal forward char (or stale suggestion - ignore it)
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        region_highlight=()
        zle .forward-char
    fi
}
zle -N forward-char _ai_forward_char

# ZLE widget: Accept next token from ghost text (Alt+Right)
_ai_accept_token() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} && "$_AI_CURRENT_SUGGESTION" == "$BUFFER"* ]]; then
        local remainder="${_AI_CURRENT_SUGGESTION:$CURSOR}"
        local leading="${remainder%%[![:space:]]*}"
        remainder="${remainder#$leading}"
        if [[ -z "$remainder" ]]; then
            return
        fi
        local ws_part="${remainder%%[[:space:]]*}"
        local slash_part="${remainder%%/*}"
        local token="$ws_part"
        if [[ "$remainder" == *"/"* ]] && (( ${#slash_part} < ${#ws_part} )); then
            token="${slash_part}/"
        fi
        local after="${remainder#$token}"
        local trailing="${after%%[![:space:]]*}"
        local insert="${leading}${token}${trailing}"
        BUFFER+="$insert"
        CURSOR=${#BUFFER}
        _ai_update_suggestion
        return
    fi
    zle .forward-word
}
zle -N _ai_accept_token

# Bind Alt+Right to accept next token (common escape sequence)
bindkey '\e[1;3C' _ai_accept_token

# ZLE widget: Clear suggestion
_ai_clear_suggestion() {
    _AI_CURRENT_SUGGESTION=""
    POSTDISPLAY=""
    > "$_AI_SUGGEST_FILE"
    zle reset-prompt
}
zle -N _ai_clear_suggestion

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion
# This works with speech-to-text tools like Wispr Flow that use the same hotkey
#
# Use ? prefix for natural language input (e.g., "?list all files")
# The ? prefix is intercepted by ZLE before shell evaluation

_AI_VOICE_MODE=false

# ZLE widget: Enter voice mode
_ai_enter_voice_mode() {
    _AI_VOICE_MODE=true
    POSTDISPLAY=" ðŸŽ¤ Voice mode"
    zle redisplay
}
zle -N _ai_enter_voice_mode

# ZLE widget: Execute with voice conversion if in voice mode or ? prefix
_ai_voice_accept_line() {
    # Check for ? prefix (natural language marker)
    # Intercepted by ZLE before shell evaluation
    if [[ "$BUFFER" == '?'* && ${#BUFFER} -gt 1 ]]; then
        local voice_input="${BUFFER#\?}"  # Remove the ? prefix
        voice_input="${voice_input## }"   # Remove leading space if any
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi

    # Check for explicit voice mode
    if [[ "$_AI_VOICE_MODE" == "true" && -n "$BUFFER" ]]; then
        # Convert the buffer through voice command
        _AI_VOICE_MODE=false
        POSTDISPLAY=""
        local voice_input="$BUFFER"
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi
    # Normal accept-line behavior
    _AI_VOICE_MODE=false
    _AI_CURRENT_SUGGESTION=""
    POSTDISPLAY=""
    region_highlight=()
    zle accept-line
}
zle -N _ai_voice_accept_line

# Bind Enter to voice-aware accept
bindkey '^M' _ai_voice_accept_line    # Enter

# Bind Ctrl+V for voice mode (Cmd+Ctrl doesn't produce a terminal sequence)
# Users can rebind this or use their speech-to-text tool's hotkey
bindkey '^X^V' _ai_enter_voice_mode   # Ctrl+X Ctrl+V

# ============================================
# Feature 2: Command Logging Hooks
# ============================================

# Log command start (runs before each command)
_ai_preexec() {
    # Skip if no command
    [[ -z "$1" ]] && return

    # Generate unique command ID (use seconds + random for uniqueness)
    _CLAI_COMMAND_ID="${CLAI_SESSION_ID}-$(date +%s)-${RANDOM}"
    # Store start time in milliseconds (macOS date doesn't support %N)
    _CLAI_COMMAND_START_TIME=$(($(date +%s) * 1000))
    _CLAI_LAST_COMMAND="$1"

    # Fire and forget - log command start to daemon
    (clai-shim log-start \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --cwd="$PWD" \
        --command="$1" >/dev/null 2>&1 &)
}

# Log command end and update suggestion (runs after each command)
_ai_precmd() {
    local exit_code=$?

    # Log command completion if we have a pending command
    if [[ -n "$_CLAI_COMMAND_ID" ]]; then
        local end_time=$(($(date +%s) * 1000))
        local duration=$((end_time - _CLAI_COMMAND_START_TIME))

        # Fire and forget - log command end to daemon
        (clai-shim log-end \
            --session-id="$CLAI_SESSION_ID" \
            --command-id="$_CLAI_COMMAND_ID" \
            --exit-code="$exit_code" \
            --duration="$duration" >/dev/null 2>&1 &)

        # Clear command tracking state
        _CLAI_COMMAND_ID=""
        _CLAI_COMMAND_START_TIME=""
    fi

    # Show AI suggestion if available (buffer will be empty)
    _ai_update_suggestion
}

# Register hooks
autoload -U add-zsh-hook
add-zsh-hook preexec _ai_preexec
add-zsh-hook precmd _ai_precmd

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${pipestatus[1]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
# Note: In zsh, `history` is often aliased to `fc -l`. We must use the
# `function` keyword to prevent alias expansion during parsing (unalias
# runs at execution time, but aliases expand at parse time).
unalias history 2>/dev/null
function history {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to zsh's native history (fc -l)
        shift
        fc -l "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            echo "$output"
        else
            # Fall back to shell's native history
            fc -l "$@"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(fc -ln -1)}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(fc -ln -5 2>/dev/null | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}


# ============================================
# Feature 4: Suggestion + History Pickers
# ============================================
# - Tab opens suggestion picker
# - Up arrow opens history picker
# - Up/Down navigate while picker is open
# - Enter accepts selection (insert only)
# - Esc cancels and restores original buffer

_CLAI_PICKER_ITEMS=()
_CLAI_PICKER_INDEX=0
_CLAI_PICKER_ACTIVE=false
_CLAI_PICKER_MODE=""
_CLAI_PICKER_ORIG_BUFFER=""
_CLAI_PICKER_ORIG_CURSOR=0
_CLAI_PICKER_PAGE=0
_CLAI_PICKER_AT_END=false
_CLAI_HISTORY_SCOPE="session"

_clai_config_enabled() {
    local enabled
    enabled=$(clai config suggestions.enabled 2>/dev/null)
    [[ "$enabled" != "false" ]]
}

_clai_history_args() {
    case "$_CLAI_HISTORY_SCOPE" in
        session)
            echo "--session=$CLAI_SESSION_ID"
            ;;
        cwd)
            echo "--session=$CLAI_SESSION_ID --cwd=$PWD"
            ;;
        global)
            echo "--global"
            ;;
        *)
            echo "--session=$CLAI_SESSION_ID"
            ;;
    esac
}

_clai_picker_load() {
    local offset="${1:-0}"
    local -a items
    if [[ "$_CLAI_PICKER_MODE" == "suggest" ]]; then
        if [[ -n "$BUFFER" ]]; then
            items=(${(f)"$(clai suggest --limit "$CLAI_MENU_LIMIT" "$BUFFER" 2>/dev/null)"})
        else
            # Intentional: with empty BUFFER, 'clai suggest' only returns the
            # single cached AI suggestion which isn't useful for a picker list.
            # Fall back to recent session history instead.
            items=(${(f)"$(clai history --limit "$CLAI_MENU_LIMIT" --offset "$offset" --session="$CLAI_SESSION_ID" 2>/dev/null)"})
        fi
    else
        local -a args
        args=(${(z)$(_clai_history_args)})
        if [[ -n "$BUFFER" ]]; then
            items=(${(f)"$(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" --offset "$offset" "$BUFFER" 2>/dev/null)"})
        else
            items=(${(f)"$(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" --offset "$offset" 2>/dev/null)"})
        fi
    fi

    # Deduplicate while preserving order (zsh unique flag)
    _CLAI_PICKER_ITEMS=("${(u)items[@]}")
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    # If fewer items returned than the limit, we've reached the end
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -lt $CLAI_MENU_LIMIT ]]; then
        _CLAI_PICKER_AT_END=true
    else
        _CLAI_PICKER_AT_END=false
    fi
    return 0
}

_clai_picker_render() {
    local menu_text=""
    local header="Suggestions"
    if [[ "$_CLAI_PICKER_MODE" == "history" ]]; then
        header="History (${_CLAI_HISTORY_SCOPE})"
    fi

    # Render items in reversed order: last array item at top, first at bottom.
    # Index 0 is the closest/newest match and appears at the bottom of the menu.
    local count=${#_CLAI_PICKER_ITEMS[@]}
    local i=$((count - 1))
    while [[ $i -ge 0 ]]; do
        local item="${_CLAI_PICKER_ITEMS[$i + 1]}"  # zsh 1-based
        if [[ $i -eq $_CLAI_PICKER_INDEX ]]; then
            menu_text+=$'\n'" â†’ $item"
        else
            menu_text+=$'\n'"   $item"
        fi
        ((i--))
    done
    POSTDISPLAY=""
    region_highlight=()
    zle -M "$header (â†‘â†“, Enter, Ctrl+C):$menu_text"
}

_clai_picker_open() {
    local mode="$1"
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        return 1
    fi
    if ! _clai_config_enabled; then
        return 1
    fi

    _CLAI_PICKER_MODE="$mode"
    _CLAI_PICKER_ORIG_BUFFER="$BUFFER"
    _CLAI_PICKER_ORIG_CURSOR=$CURSOR
    _CLAI_PICKER_ACTIVE=true
    _CLAI_PICKER_INDEX=0
    _CLAI_PICKER_PAGE=0
    _CLAI_PICKER_AT_END=false

    if ! _clai_picker_load 0; then
        _CLAI_PICKER_ACTIVE=false
        zle -M "No ${mode} items"
        return
    fi
    _clai_picker_render
}

_clai_picker_close() {
    _CLAI_PICKER_ACTIVE=false
    _CLAI_PICKER_ITEMS=()
    _CLAI_PICKER_INDEX=0
    _CLAI_PICKER_PAGE=0
    _CLAI_PICKER_AT_END=false
    _CLAI_PICKER_MODE=""
    zle -M ""
}

_clai_picker_cancel() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        BUFFER="$_CLAI_PICKER_ORIG_BUFFER"
        CURSOR=$_CLAI_PICKER_ORIG_CURSOR
        _clai_picker_close
        _ai_update_suggestion
        zle redisplay
    fi
}

_clai_picker_accept() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX + 1]}"
        BUFFER="$selected"
        CURSOR=${#BUFFER}
        _clai_picker_close
        _ai_update_suggestion
        zle redisplay
    else
        _ai_voice_accept_line
    fi
}

_clai_picker_up() {
    # Fast path: if picker is already open, navigate without external commands
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        local last_index=$((${#_CLAI_PICKER_ITEMS[@]} - 1))
        if [[ $_CLAI_PICKER_INDEX -lt $last_index ]]; then
            # Move up in the visual list (toward older items)
            ((_CLAI_PICKER_INDEX++))
            _clai_picker_render
        elif [[ "$_CLAI_PICKER_AT_END" != "true" ]]; then
            # At top of current page and more items exist â€” load next page
            ((_CLAI_PICKER_PAGE++))
            local offset=$((_CLAI_PICKER_PAGE * CLAI_MENU_LIMIT))
            if _clai_picker_load "$offset"; then
                # Place cursor at bottom after paging (newest item on new page)
                _CLAI_PICKER_INDEX=0
                local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX + 1]}"
                if [[ -n "$selected" ]]; then
                    BUFFER="$selected"
                    CURSOR=${#BUFFER}
                fi
                _clai_picker_render
            else
                # No more items â€” mark end and stay put
                _CLAI_PICKER_AT_END=true
                ((_CLAI_PICKER_PAGE--))
            fi
        fi
        # At end and at top: do nothing (no more items)
        return
    fi
    # Not in picker - check config before opening (expensive, runs once)
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off || ! _clai_config_enabled; then
        zle .up-line-or-history
        return
    fi
    _clai_picker_open history
}

_clai_picker_down() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        if [[ $_CLAI_PICKER_INDEX -gt 0 ]]; then
            # Move down in the visual list (toward newer items)
            ((_CLAI_PICKER_INDEX--))
            _clai_picker_render
        fi
        # At bottom (index 0): do nothing
        return
    fi
    zle .down-line-or-history
}

_clai_picker_suggest() {
    _clai_picker_open suggest || return
}

_clai_history_scope_session() {
    _CLAI_HISTORY_SCOPE="session"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: session"
    fi
}

_clai_history_scope_cwd() {
    _CLAI_HISTORY_SCOPE="cwd"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: cwd"
    fi
}

_clai_history_scope_global() {
    _CLAI_HISTORY_SCOPE="global"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: global"
    fi
}

# Cancel picker or send-break (overrides default send-break for Ctrl+C/Ctrl+G)
_clai_picker_break() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        _clai_picker_cancel
        return
    fi
    zle .send-break
}

zle -N _clai_picker_suggest
zle -N _clai_picker_up
zle -N _clai_picker_down
zle -N _clai_picker_accept
zle -N _clai_history_scope_session
zle -N _clai_history_scope_cwd
zle -N _clai_history_scope_global
zle -N send-break _clai_picker_break

bindkey '^I' _clai_picker_suggest      # Tab
bindkey '^[[A' _clai_picker_up         # Up arrow (CSI mode)
bindkey '^[OA' _clai_picker_up         # Up arrow (application mode)
bindkey '^[[B' _clai_picker_down       # Down arrow (CSI mode)
bindkey '^[OB' _clai_picker_down       # Down arrow (application mode)
bindkey '^M' _clai_picker_accept       # Enter
bindkey '^Xs' _clai_history_scope_session
bindkey '^Xd' _clai_history_scope_cwd
bindkey '^Xg' _clai_history_scope_global
# Note: bare '\e' binding removed â€” it intercepts arrow key sequences when
# KEYTIMEOUT is low (common in oh-my-zsh, vi-mode configs). Picker cancel
# is handled via send-break (Ctrl+C / Ctrl+G) instead.

# ============================================
# Full Disable / Enable (clai off / clai on)
# ============================================

_clai_disable() {
    export CLAI_OFF=1

    # Restore default ZLE widgets (undo custom overrides)
    zle -A .self-insert self-insert
    zle -A .backward-delete-char backward-delete-char
    zle -A .backward-char backward-char
    zle -A .beginning-of-line beginning-of-line
    zle -A .end-of-line end-of-line
    zle -A .forward-char forward-char
    zle -A .bracketed-paste bracketed-paste
    zle -A .send-break send-break

    # Restore default keybindings
    bindkey '^I' expand-or-complete
    bindkey '^M' accept-line
    bindkey '^[[A' up-line-or-history
    bindkey '^[OA' up-line-or-history
    bindkey '^[[B' down-line-or-history
    bindkey '^[OB' down-line-or-history
    bindkey '\e[1;3C' forward-word
    bindkey -r '^X^V'
    bindkey -r '^Xs'
    bindkey -r '^Xd'
    bindkey -r '^Xg'

    # Restore zsh-autosuggestions
    _clai_zsh_autosuggest_restore

    # Remove hooks
    add-zsh-hook -d preexec _ai_preexec
    add-zsh-hook -d precmd _ai_precmd

    # Clear ghost text
    POSTDISPLAY=""
    region_highlight=()

    # Restore native history command
    unfunction history 2>/dev/null

    echo "clai disabled â€” native shell restored"
}

_clai_enable() {
    unset CLAI_OFF
    _CLAI_REINIT=1
    eval "$(command clai init zsh)"
    unset _CLAI_REINIT
    echo "clai enabled"
}

# Wrapper function: intercepts off/on to run shell-native disable/enable
clai() {
    case "$1" in
        off)
            command clai off --session
            _clai_disable
            ;;
        on)
            command clai on --session
            _clai_enable
            ;;
        *)
            command clai "$@"
            ;;
    esac
}

# ============================================
# Daemon Management
# ============================================

# Daemon control commands (Claude daemon for fast voice, started lazily on first use)
ai-daemon() {
    case "$1" in
        start)
            clai daemon start
            ;;
        stop)
            clai daemon stop
            ;;
        status)
            clai daemon status
            ;;
        restart)
            clai daemon stop
            clai daemon start
            ;;
        *)
            echo "Usage: ai-daemon {start|stop|status|restart}"
            echo "  Manages the background Claude daemon for fast voice responses"
            ;;
    esac
}

# ============================================
# Startup
# ============================================

# Cleanup function for shell exit
_clai_cleanup() {
    # Notify daemon session is ending
    clai-shim session-end --session-id="$CLAI_SESSION_ID" >/dev/null 2>&1 &!
}

if [[ -o interactive && -z "$_CLAI_REINIT" ]]; then
    # Notify daemon of new session (fire and forget)
    # Note: claid starts lazily via clai-shim -> ipc.NewClient() -> EnsureDaemon()
    (clai-shim session-start \
        --session-id="$CLAI_SESSION_ID" \
        --cwd="$PWD" \
        --shell=zsh >/dev/null 2>&1 &)

    trap '_clai_cleanup' EXIT HUP

    local short_id="${CLAI_SESSION_ID:0:8}"
    echo -e "\033[2mðŸ¤– clai [$short_id] Tab suggestions | â†‘ history | â†’ accept | ?\"describe task\"\033[0m"
fi
