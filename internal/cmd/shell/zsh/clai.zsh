# clai.zsh - clai shell integration for Zsh
# Generated by: clai init zsh
#
# Features:
#   1. Session tracking (commands logged for context-aware suggestions)
#   2. Inline command suggestions (history + AI) with right-arrow to accept
#   3. Menu selection with Ctrl+Space (up/down to navigate, Enter to select)
#   4. Error diagnosis with `run` wrapper (captures output for analysis)
#   5. Voice mode with ` prefix (fast with Haiku daemon)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_DAEMON=true     # Auto-start daemon for fast voice (default: true)
#   CLAI_MENU_LIMIT=5         # Max suggestions in menu (default: 5)

# ============================================
# Configuration
# ============================================

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_AUTO_DAEMON:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Session Tracking
# ============================================
# Generate unique session ID for this shell instance
# This enables context-aware suggestions across commands

# Generate session ID (use uuidgen if available, fallback to date+pid)
if command -v uuidgen >/dev/null 2>&1; then
    export CLAI_SESSION_ID=$(uuidgen | tr '[:upper:]' '[:lower:]')
else
    export CLAI_SESSION_ID="$(date +%s)-$$"
fi

# Command tracking state
_CLAI_COMMAND_ID=""
_CLAI_COMMAND_START_TIME=""
_CLAI_LAST_COMMAND=""

# ============================================
# Feature 1: Command Suggestion (History + AI)
# ============================================
# Shows inline ghost text suggestions as you type
# - While typing: matches against shell history
# - Empty buffer: shows AI suggestion if available
# - Right-arrow to accept

# Current suggestion state
_AI_CURRENT_SUGGESTION=""

# Update suggestion based on current buffer
_ai_update_suggestion() {
    local suggestion=""

    if [[ -z "$BUFFER" ]]; then
        # Empty buffer - check for AI suggestion
        suggestion=$(clai suggest 2>/dev/null)
    else
        # Has content - search history
        suggestion=$(clai suggest "$BUFFER" 2>/dev/null)
    fi

    _AI_CURRENT_SUGGESTION="$suggestion"

    # Clear ghost text (we use right prompt now)
    POSTDISPLAY=""

    # Show suggestion in right prompt
    if [[ -n "$suggestion" && "$suggestion" != "$BUFFER" ]]; then
        local display_suggestion="$suggestion"
        local display_prefix="$BUFFER"
        local max_suggestion=40  # Max length for suggestion
        local max_prefix=10      # Max length for prefix display

        # Truncate long suggestions
        if [[ ${#display_suggestion} -gt $max_suggestion ]]; then
            display_suggestion="${display_suggestion:0:$max_suggestion}â€¦"
        fi

        if [[ -z "$BUFFER" ]]; then
            # No input yet - show full suggestion
            RPS1="%F{242}($display_suggestion)%f"
        else
            # Truncate long prefix to just "..."
            if [[ ${#display_prefix} -gt $max_prefix ]]; then
                display_prefix="â€¦"
            fi
            # Show (partial â†’ full) format
            RPS1="%F{242}($display_prefix â†’ $display_suggestion)%f"
        fi
    else
        RPS1=""
    fi

    # Force prompt redraw to show updated RPS1 (only when in ZLE context)
    [[ -n "$WIDGET" ]] && zle reset-prompt
}

# ZLE widget: Update suggestion after each character
_ai_self_insert() {
    zle .self-insert
    _ai_update_suggestion
}
zle -N self-insert _ai_self_insert

# ZLE widget: Update suggestion after backspace
_ai_backward_delete_char() {
    zle .backward-delete-char
    _ai_update_suggestion
}
zle -N backward-delete-char _ai_backward_delete_char

# ZLE widget: Accept suggestion with right arrow
_ai_forward_char() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} ]]; then
        # At end of buffer with suggestion - accept it
        BUFFER="$_AI_CURRENT_SUGGESTION"
        CURSOR=${#BUFFER}
        RPS1=""
        _AI_CURRENT_SUGGESTION=""
        # Clear AI suggestion file if we used it
        > "$_AI_SUGGEST_FILE"
        zle reset-prompt
    else
        # Normal forward char
        zle .forward-char
    fi
}
zle -N forward-char _ai_forward_char

# ZLE widget: Clear suggestion with Escape
_ai_clear_suggestion() {
    RPS1=""
    _AI_CURRENT_SUGGESTION=""
    > "$_AI_SUGGEST_FILE"
    zle reset-prompt
}
zle -N _ai_clear_suggestion

# Note: Escape is bound later to _ai_cancel_voice_mode which calls _ai_clear_suggestion

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion
# This works with speech-to-text tools like Wispr Flow that use the same hotkey
#
# Use ` prefix for voice input (e.g., "`list all files")
# The ` prefix is intercepted by ZLE before shell evaluation

_AI_VOICE_MODE=false

# ZLE widget: Enter voice mode
_ai_enter_voice_mode() {
    _AI_VOICE_MODE=true
    POSTDISPLAY=" ðŸŽ¤ Voice mode"
    zle redisplay
}
zle -N _ai_enter_voice_mode

# ZLE widget: Execute with voice conversion if in voice mode or ` prefix
_ai_voice_accept_line() {
    # Check for ` prefix (voice input marker)
    # Intercepted by ZLE before shell evaluation, so backtick is safe
    if [[ "$BUFFER" == '`'* && ${#BUFFER} -gt 1 ]]; then
        local voice_input="${BUFFER#\`}"  # Remove the ` prefix
        voice_input="${voice_input## }"   # Remove leading space if any
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "ðŸŽ¤ Converting: $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi

    # Check for explicit voice mode
    if [[ "$_AI_VOICE_MODE" == "true" && -n "$BUFFER" ]]; then
        # Convert the buffer through voice command
        _AI_VOICE_MODE=false
        POSTDISPLAY=""
        local voice_input="$BUFFER"
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "ðŸŽ¤ Converting: $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi
    # Normal accept-line behavior
    _AI_VOICE_MODE=false
    zle accept-line
}
zle -N _ai_voice_accept_line

# ZLE widget: Cancel voice mode with Escape
_ai_cancel_voice_mode() {
    if [[ "$_AI_VOICE_MODE" == "true" ]]; then
        _AI_VOICE_MODE=false
    fi
    # Clear suggestions
    _ai_clear_suggestion
}
zle -N _ai_cancel_voice_mode

# Bind Enter to voice-aware accept
bindkey '^M' _ai_voice_accept_line    # Enter

# Bind Ctrl+V for voice mode (Cmd+Ctrl doesn't produce a terminal sequence)
# Users can rebind this or use their speech-to-text tool's hotkey
bindkey '^X^V' _ai_enter_voice_mode   # Ctrl+X Ctrl+V

# Override escape to also cancel voice mode
bindkey '^[' _ai_cancel_voice_mode    # Escape

# ============================================
# Feature 2: Command Logging Hooks
# ============================================

# Log command start (runs before each command)
_ai_preexec() {
    # Skip if no command
    [[ -z "$1" ]] && return

    # Generate unique command ID
    _CLAI_COMMAND_ID="${CLAI_SESSION_ID}-$(date +%s%N 2>/dev/null || echo $RANDOM)"
    _CLAI_COMMAND_START_TIME=$(date +%s%3N 2>/dev/null || date +%s)000
    _CLAI_LAST_COMMAND="$1"

    # Fire and forget - log command start to daemon
    (clai-shim log-start \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --cwd="$PWD" \
        --command="$1" >/dev/null 2>&1 &)
}

# Log command end and update suggestion (runs after each command)
_ai_precmd() {
    local exit_code=$?

    # Log command completion if we have a pending command
    if [[ -n "$_CLAI_COMMAND_ID" ]]; then
        local end_time=$(date +%s%3N 2>/dev/null || date +%s)000
        local duration=$((end_time - _CLAI_COMMAND_START_TIME))

        # Fire and forget - log command end to daemon
        (clai-shim log-end \
            --session-id="$CLAI_SESSION_ID" \
            --command-id="$_CLAI_COMMAND_ID" \
            --exit-code="$exit_code" \
            --duration="$duration" >/dev/null 2>&1 &)

        # Clear command tracking state
        _CLAI_COMMAND_ID=""
        _CLAI_COMMAND_START_TIME=""
    fi

    # Show AI suggestion if available (buffer will be empty)
    _ai_update_suggestion
}

# Register hooks
autoload -U add-zsh-hook
add-zsh-hook preexec _ai_preexec
add-zsh-hook precmd _ai_precmd

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${pipestatus[1]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(fc -ln -1)}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(fc -ln -5 2>/dev/null | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}


# ============================================
# Feature 4: Menu Selection (Ctrl+Space)
# ============================================
# Shows multiple suggestions in a selectable menu
# - Ctrl+Space: Show suggestion menu
# - Up/Down arrows: Navigate
# - Enter: Accept selection
# - Escape: Cancel

# Menu state
_AI_MENU_SUGGESTIONS=()
_AI_MENU_INDEX=0
_AI_MENU_ACTIVE=false

# Fetch suggestions and show menu
_ai_show_menu() {
    local prefix="$BUFFER"

    # Get multiple suggestions from clai
    local -a suggestions
    if [[ -n "$prefix" ]]; then
        suggestions=(${(f)"$(clai suggest --limit "$CLAI_MENU_LIMIT" "$prefix" 2>/dev/null)"})
    fi

    if [[ ${#suggestions} -eq 0 ]]; then
        zle -M "No suggestions for: $prefix"
        return
    fi

    # Store suggestions and activate menu
    _AI_MENU_SUGGESTIONS=("${suggestions[@]}")
    _AI_MENU_INDEX=0
    _AI_MENU_ACTIVE=true

    # Render the menu
    _ai_render_menu
}

# Render the current menu state
_ai_render_menu() {
    local menu_text=""
    local i=0

    for suggestion in "${_AI_MENU_SUGGESTIONS[@]}"; do
        if [[ $i -eq $_AI_MENU_INDEX ]]; then
            # Highlighted selection
            menu_text+=$'\n'" â†’ $suggestion"
        else
            menu_text+=$'\n'"   $suggestion"
        fi
        ((i++))
    done

    # Show menu below prompt
    zle -M "Suggestions (â†‘â†“ to navigate, Enter to select, Esc to cancel):$menu_text"
}

# Navigate menu up
_ai_menu_up() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        if [[ $_AI_MENU_INDEX -gt 0 ]]; then
            ((_AI_MENU_INDEX--))
        else
            # Wrap to bottom
            _AI_MENU_INDEX=$((${#_AI_MENU_SUGGESTIONS[@]} - 1))
        fi
        _ai_render_menu
    else
        zle .up-line-or-history
    fi
}

# Navigate menu down
_ai_menu_down() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        if [[ $_AI_MENU_INDEX -lt $((${#_AI_MENU_SUGGESTIONS[@]} - 1)) ]]; then
            ((_AI_MENU_INDEX++))
        else
            # Wrap to top
            _AI_MENU_INDEX=0
        fi
        _ai_render_menu
    else
        zle .down-line-or-history
    fi
}

# Accept menu selection
_ai_menu_accept() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        local selected="${_AI_MENU_SUGGESTIONS[$_AI_MENU_INDEX + 1]}"  # zsh arrays are 1-indexed
        BUFFER="$selected"
        CURSOR=${#BUFFER}
        _ai_menu_cancel
        zle redisplay
    else
        # Pass through to normal accept (voice-aware)
        _ai_voice_accept_line
    fi
}

# Cancel menu
_ai_menu_cancel() {
    _AI_MENU_ACTIVE=false
    _AI_MENU_SUGGESTIONS=()
    _AI_MENU_INDEX=0
    zle -M ""  # Clear message
}

# Register menu widgets
zle -N _ai_show_menu
zle -N _ai_menu_up
zle -N _ai_menu_down
zle -N _ai_menu_accept

# Bind Ctrl+Space to show menu
bindkey '^ ' _ai_show_menu

# Override up/down arrows when menu is active
bindkey '^[[A' _ai_menu_up     # Up arrow
bindkey '^[[B' _ai_menu_down   # Down arrow

# Override Enter when menu is active
bindkey '^M' _ai_menu_accept

# Escape cancels menu (already bound to _ai_cancel_voice_mode, update it)
_ai_cancel_voice_mode() {
    if [[ "$_AI_MENU_ACTIVE" == "true" ]]; then
        _ai_menu_cancel
        return
    fi
    if [[ "$_AI_VOICE_MODE" == "true" ]]; then
        _AI_VOICE_MODE=false
    fi
    # Clear suggestions
    _ai_clear_suggestion
}

# ============================================
# Daemon Management
# ============================================

# Start daemon in background for fast voice responses
_ai_ensure_daemon() {
    if [[ "$CLAI_AUTO_DAEMON" == "true" ]]; then
        # Check if daemon is running, start if not (silently in background)
        (clai daemon start >/dev/null 2>&1 &)
    fi
}

# Daemon control commands
ai-daemon() {
    case "$1" in
        start)
            clai daemon start
            ;;
        stop)
            clai daemon stop
            ;;
        status)
            clai daemon status
            ;;
        restart)
            clai daemon stop
            clai daemon start
            ;;
        *)
            echo "Usage: ai-daemon {start|stop|status|restart}"
            echo "  Manages the background Claude daemon for fast voice responses"
            ;;
    esac
}

# ============================================
# Startup
# ============================================

if [[ -o interactive ]]; then
    # Start daemon if enabled
    _ai_ensure_daemon

    # Notify daemon of new session (fire and forget)
    (clai-shim session-start \
        --session-id="$CLAI_SESSION_ID" \
        --cwd="$PWD" \
        --shell=zsh >/dev/null 2>&1 &)

    # Register cleanup on shell exit
    trap '_clai_cleanup' EXIT HUP

    echo -e "\033[2mðŸ¤– clai loaded. Ctrl+Space for suggestions | \` for voice | ai-fix, ai, voice, ai-daemon\033[0m"
fi

# Cleanup function for shell exit
_clai_cleanup() {
    # Notify daemon session is ending
    clai-shim session-end --session-id="$CLAI_SESSION_ID" >/dev/null 2>&1
}
