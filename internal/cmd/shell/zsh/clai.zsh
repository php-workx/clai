# clai.zsh - clai shell integration for Zsh
# Generated by: clai init zsh
#
# Features:
#   1. Session tracking (commands logged for context-aware suggestions)
#   2. Inline ghost text suggestions (history + AI) with right-arrow to accept
#   3. Suggestion picker (Tab) + history picker (â†‘) with menu navigation
#   4. Error diagnosis with `run` wrapper (captures output for analysis)
#   5. Natural language â†’ command with ? prefix (e.g., "?list all files")
#
# Configuration (set these BEFORE sourcing):
#   CLAI_MENU_LIMIT=5         # Max suggestions in menu (default: 5)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=zsh

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}
: ${CLAI_UP_ARROW_HISTORY:={{CLAI_UP_ARROW_HISTORY}}}
: ${CLAI_UP_ARROW_TRIGGER:={{CLAI_UP_ARROW_TRIGGER}}}
: ${CLAI_UP_ARROW_DOUBLE_WINDOW_MS:={{CLAI_UP_ARROW_DOUBLE_WINDOW_MS}}}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
# This enables context-aware suggestions across commands
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# Command tracking state
_CLAI_COMMAND_ID=""
_CLAI_COMMAND_START_TIME=""
_CLAI_LAST_COMMAND=""
if [[ -z "${_CLAI_ORIG_KEYTIMEOUT:-}" ]]; then
    _CLAI_ORIG_KEYTIMEOUT="${KEYTIMEOUT:-}"
fi

# ============================================
# Feature 1: Command Suggestion (History + AI)
# ============================================
# Shows inline ghost text suggestions as you type
# - While typing: matches against shell history
# - Empty buffer: shows AI suggestion if available
# - Right-arrow to accept
# - Alt+Right to accept next token

# Load datetime module for EPOCHREALTIME (double-tap detection)
zmodload -F zsh/datetime p:EPOCHREALTIME 2>/dev/null

# Current suggestion state
_AI_CURRENT_SUGGESTION=""
_AI_LAST_ACCEPTED=""
_AI_IN_PASTE=false
_AI_GHOST_HIGHLIGHT=""
_AI_GHOST_META=""

# Double-tap up-arrow detection
_CLAI_DOUBLE_TAP_THRESHOLD=0.5
_CLAI_LAST_UP_TIME=-1

# Disable zsh-autosuggestions when clai is active
_CLAI_ZSH_AUTOSUGGEST_PRESENT=false
if (( ${+functions[_zsh_autosuggest_start]} )); then
    _CLAI_ZSH_AUTOSUGGEST_PRESENT=true
fi
_CLAI_ZSH_AUTOSUGGEST_ORIG="${ZSH_AUTOSUGGEST_DISABLE:-}"

_clai_zsh_autosuggest_disable() {
    if [[ "$_CLAI_ZSH_AUTOSUGGEST_PRESENT" == "true" ]]; then
        export ZSH_AUTOSUGGEST_DISABLE=1
    fi
}

_clai_zsh_autosuggest_restore() {
    if [[ "$_CLAI_ZSH_AUTOSUGGEST_PRESENT" == "true" ]]; then
        if [[ -n "$_CLAI_ZSH_AUTOSUGGEST_ORIG" ]]; then
            export ZSH_AUTOSUGGEST_DISABLE="$_CLAI_ZSH_AUTOSUGGEST_ORIG"
        else
            unset ZSH_AUTOSUGGEST_DISABLE
        fi
    fi
}

# Session-level disable flag
_clai_session_off() {
    [[ -f "$CLAI_CACHE/off" ]]
}

_ai_remove_ghost_highlight() {
    local kept=()
    local h
    for h in "${region_highlight[@]}"; do
        if [[ "$h" == *fg=242 ]]; then
            continue
        fi
        kept+=("$h")
    done
    region_highlight=("${kept[@]}")
    _AI_GHOST_HIGHLIGHT=""
}

# Update suggestion based on current buffer
_ai_update_suggestion() {
    local suggestion=""
    local meta=""

    # Hide ghost text when disabled, picker active, buffer empty, or cursor not at EOL
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off || [[ "$_CLAI_PICKER_ACTIVE" == "true" ]] || [[ -z "$BUFFER" ]] || [[ $CURSOR -ne ${#BUFFER} ]]; then
        _clai_zsh_autosuggest_restore
        # Dismiss feedback if suggestion was visible and buffer changed
        if [[ -n "$_AI_CURRENT_SUGGESTION" ]]; then
            (clai suggest-feedback --action=dismissed --suggested="$_AI_CURRENT_SUGGESTION" >/dev/null 2>&1 &)
        fi
        _AI_CURRENT_SUGGESTION=""
        _AI_GHOST_META=""
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        return
    fi

    _clai_zsh_autosuggest_disable
    # Has content - clai handles daemon vs history fallback
    local out=""
    out=$(clai suggest --format ghost --limit 1 "$BUFFER" 2>/dev/null)
    suggestion="${out%%$'\t'*}"
    if [[ "$out" == *$'\t'* ]]; then
        meta="${out#*$'\t'}"
    fi

    if [[ -n "$suggestion" && "$suggestion" != "$BUFFER" && "$suggestion" == "$BUFFER"* ]]; then
        _AI_CURRENT_SUGGESTION="$suggestion"
        _AI_GHOST_META="$meta"
        local ghost="${suggestion:${#BUFFER}}"
        local display="${ghost}"
        if [[ -n "$meta" ]]; then
            display="${ghost}  ${meta}"
        fi
        POSTDISPLAY="${display}"
        # region_highlight colors POSTDISPLAY; positions past ${#BUFFER} target it.
        # Preserve any existing region_highlight from other plugins (e.g. zsh-syntax-highlighting).
        _ai_remove_ghost_highlight
        _AI_GHOST_HIGHLIGHT="${#BUFFER} $((${#BUFFER} + ${#display})) fg=242"
        region_highlight+=("$_AI_GHOST_HIGHLIGHT")
    else
        _AI_CURRENT_SUGGESTION=""
        _AI_GHOST_META=""
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
    fi

    [[ -n "$WIDGET" ]] && zle reset-prompt
}

# ZLE widget: Update suggestion after each character
_ai_self_insert() {
    _clai_dismiss_picker
    zle .self-insert
    # During bracketed paste (or any queued bulk input), avoid running
    # `clai suggest` per character. Recompute once when the queue drains.
    if [[ "$_AI_IN_PASTE" == "true" ]] || [[ ${KEYS_QUEUED_COUNT:-0} -gt 0 ]]; then
        return
    fi
    _ai_update_suggestion
}
zle -N self-insert _ai_self_insert

# ZLE widget: Space is often bound to magic-space (history expansion), not self-insert.
# Wrap it so suggestions remain ghost-rendered and up-to-date after inserting a space.
_ai_magic_space() {
    _clai_dismiss_picker
    zle .magic-space
    if [[ "$_AI_IN_PASTE" == "true" ]] || [[ ${KEYS_QUEUED_COUNT:-0} -gt 0 ]]; then
        return
    fi
    _ai_update_suggestion
}
zle -N magic-space _ai_magic_space

# Dismiss picker if active (called by editing/movement widgets).
# Uses _clai_picker_close (defined in picker section) via forward reference;
# safe because widgets are only invoked after full script is sourced.
_clai_dismiss_picker() {
    [[ "$_CLAI_PICKER_ACTIVE" == "true" ]] && _clai_picker_close
}

# Clear inline ghost text state (without touching suggestion cache on disk).
_ai_clear_ghost_text() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" ]]; then
        # Record dismissed feedback (fire and forget)
        (clai suggest-feedback --action=dismissed --suggested="$_AI_CURRENT_SUGGESTION" >/dev/null 2>&1 &)
    fi
    _AI_CURRENT_SUGGESTION=""
    _AI_GHOST_META=""
    POSTDISPLAY=""
    _ai_remove_ghost_highlight
}

# Safety net: keep ghost text consistent if BUFFER/CURSOR changes via an unwrapped ZLE widget.
_ai_sync_ghost_text() {
    # If POSTDISPLAY is somehow set without a suggestion, clear it.
    if [[ -z "$_AI_CURRENT_SUGGESTION" ]]; then
        if [[ -n "$POSTDISPLAY" ]]; then
            POSTDISPLAY=""
            _ai_remove_ghost_highlight
        fi
        return
    fi

    # Ghost text is only valid when suggestion is a prefix extension of BUFFER
    # and the cursor is at EOL (otherwise POSTDISPLAY would appear in the wrong place).
    if [[ -z "$BUFFER" ]] || [[ $CURSOR -ne ${#BUFFER} ]] || [[ "$_AI_CURRENT_SUGGESTION" != "$BUFFER"* ]]; then
        _ai_clear_ghost_text
        return
    fi

    # BUFFER still matches the current suggestion; recompute POSTDISPLAY and highlight
    # based on the new BUFFER length (e.g., space inserts via magic-space).
    local ghost="${_AI_CURRENT_SUGGESTION:${#BUFFER}}"
    if [[ -z "$ghost" ]]; then
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        return
    fi
    local display="${ghost}"
    if [[ -n "$_AI_GHOST_META" ]]; then
        display="${ghost}  ${_AI_GHOST_META}"
    fi
    POSTDISPLAY="${display}"
    _ai_remove_ghost_highlight
    _AI_GHOST_HIGHLIGHT="${#BUFFER} $((${#BUFFER} + ${#display})) fg=242"
    region_highlight+=("$_AI_GHOST_HIGHLIGHT")
}

_ai_zle_line_pre_redraw() {
    # Don't interfere while the inline picker owns the UI.
    [[ "$_CLAI_PICKER_ACTIVE" == "true" ]] && return
    _ai_sync_ghost_text
}
autoload -U add-zle-hook-widget 2>/dev/null
if (( ${+functions[add-zle-hook-widget]} )); then
    add-zle-hook-widget zle-line-pre-redraw _ai_zle_line_pre_redraw
else
    zle -N zle-line-pre-redraw _ai_zle_line_pre_redraw
fi

# ZLE widget: Tab completion should dismiss ghost text first.
_ai_expand_or_complete() {
    _clai_dismiss_picker
    _ai_clear_ghost_text
    zle .expand-or-complete
}
zle -N expand-or-complete _ai_expand_or_complete

# ZLE widget: History navigation keeps ghost text (re-generated for new buffer).
# Uses prefix search: when the buffer has content, only matching history entries
# are shown. When empty, cycles through all history (same as before).
_ai_up_line_or_history() {
    _clai_dismiss_picker
    zle .history-beginning-search-backward
    _ai_update_suggestion
}
zle -N up-line-or-history _ai_up_line_or_history

_ai_down_line_or_history() {
    _clai_dismiss_picker
    zle .history-beginning-search-forward
    _ai_update_suggestion
}
zle -N down-line-or-history _ai_down_line_or_history

# ZLE widget: Update suggestion after backspace
_ai_backward_delete_char() {
    _clai_dismiss_picker
    zle .backward-delete-char
    _ai_update_suggestion
}
zle -N backward-delete-char _ai_backward_delete_char

# ZLE widget: Update suggestion after cursor movement
_ai_backward_char() {
    _clai_dismiss_picker
    # Left-arrow should never "accept" a suggestion. Clear ghost text so cursor
    # movement doesn't feel like it jumps behind POSTDISPLAY.
    _ai_clear_ghost_text
    zle .backward-char
    _ai_update_suggestion
}
zle -N backward-char _ai_backward_char

_ai_beginning_of_line() {
    _clai_dismiss_picker
    zle .beginning-of-line
    _ai_update_suggestion
}
zle -N beginning-of-line _ai_beginning_of_line

_ai_end_of_line() {
    _clai_dismiss_picker
    zle .end-of-line
    _ai_update_suggestion
}
zle -N end-of-line _ai_end_of_line

# ZLE widget: Handle bracketed paste as a single update
_ai_bracketed_paste() {
    _clai_dismiss_picker
    _AI_IN_PASTE=true
    zle .bracketed-paste
    _AI_IN_PASTE=false
    _ai_update_suggestion
}
zle -N bracketed-paste _ai_bracketed_paste

# ZLE widget: Accept suggestion with right arrow
_ai_forward_char() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} && "$_AI_CURRENT_SUGGESTION" == "$BUFFER"* ]]; then
        # At end of buffer with valid suggestion prefix - accept it
        local accepted="$_AI_CURRENT_SUGGESTION"
        BUFFER="$_AI_CURRENT_SUGGESTION"
        CURSOR=${#BUFFER}
        _AI_CURRENT_SUGGESTION=""
        _AI_GHOST_META=""
        _AI_LAST_ACCEPTED="$accepted"
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        # Clear AI suggestion file if we used it
        > "$_AI_SUGGEST_FILE"
        # Record accepted feedback (fire and forget)
        (clai suggest-feedback --action=accepted --suggested="$accepted" >/dev/null 2>&1 &)
        zle reset-prompt
    else
        # Normal forward char (or stale suggestion - ignore it)
        _AI_CURRENT_SUGGESTION=""
        _AI_GHOST_META=""
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        zle .forward-char
    fi
}
zle -N forward-char _ai_forward_char

# ZLE widget: Accept next token from ghost text (Alt+Right)
_ai_accept_token() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" && $CURSOR -eq ${#BUFFER} && "$_AI_CURRENT_SUGGESTION" == "$BUFFER"* ]]; then
        local remainder="${_AI_CURRENT_SUGGESTION:$CURSOR}"
        local leading="${remainder%%[![:space:]]*}"
        remainder="${remainder#$leading}"
        if [[ -z "$remainder" ]]; then
            return
        fi
        local ws_part="${remainder%%[[:space:]]*}"
        local slash_part="${remainder%%/*}"
        local token="$ws_part"
        if [[ "$remainder" == *"/"* ]] && (( ${#slash_part} < ${#ws_part} )); then
            token="${slash_part}/"
        fi
        local after="${remainder#$token}"
        local trailing="${after%%[![:space:]]*}"
        local insert="${leading}${token}${trailing}"
        BUFFER+="$insert"
        CURSOR=${#BUFFER}
        _ai_update_suggestion
        return
    fi
    zle .forward-word
}
zle -N _ai_accept_token

# Bind Alt+Right to accept next token (common escape sequence)
bindkey '\e[1;3C' _ai_accept_token

# ZLE widget: Clear suggestion (Escape dismisses)
_ai_clear_suggestion() {
    if [[ -n "$_AI_CURRENT_SUGGESTION" ]]; then
        # Record dismissed feedback (fire and forget)
        (clai suggest-feedback --action=dismissed --suggested="$_AI_CURRENT_SUGGESTION" >/dev/null 2>&1 &)
    fi
    _AI_CURRENT_SUGGESTION=""
    POSTDISPLAY=""
    > "$_AI_SUGGEST_FILE"
    zle reset-prompt
}
zle -N _ai_clear_suggestion

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion
# This works with speech-to-text tools like Wispr Flow that use the same hotkey
#
# Use ? prefix for natural language input (e.g., "?list all files")
# The ? prefix is intercepted by ZLE before shell evaluation

_AI_VOICE_MODE=false

# ZLE widget: Enter voice mode
_ai_enter_voice_mode() {
    _AI_VOICE_MODE=true
    POSTDISPLAY=" ðŸŽ¤ Voice mode"
    zle redisplay
}
zle -N _ai_enter_voice_mode

# ZLE widget: Execute with voice conversion if in voice mode or ? prefix
_ai_voice_accept_line() {
    # Check for ? prefix (natural language marker)
    # Intercepted by ZLE before shell evaluation
    if [[ "$BUFFER" == '?'* && ${#BUFFER} -gt 1 ]]; then
        local voice_input="${BUFFER#\?}"  # Remove the ? prefix
        voice_input="${voice_input## }"   # Remove leading space if any
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi

    # Check for explicit voice mode
    if [[ "$_AI_VOICE_MODE" == "true" && -n "$BUFFER" ]]; then
        # Convert the buffer through voice command
        _AI_VOICE_MODE=false
        POSTDISPLAY=""
        local voice_input="$BUFFER"
        BUFFER=""
        zle redisplay

        # Run voice conversion and show result
        echo ""
        echo "? $voice_input"
        local cmd=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$cmd" ]]; then
            echo "â†’ $cmd"
            # Suggestion is cached by clai voice; Tab to accept
        fi
        zle reset-prompt
        return
    fi
    # Normal accept-line behavior
    _AI_VOICE_MODE=false
    # Track edited suggestion feedback: if user modified an accepted suggestion
    if [[ -n "$_AI_LAST_ACCEPTED" && -n "$BUFFER" && "$BUFFER" != "$_AI_LAST_ACCEPTED" ]]; then
        (clai suggest-feedback --action=edited --suggested="$_AI_LAST_ACCEPTED" --executed="$BUFFER" >/dev/null 2>&1 &)
    fi
    _AI_LAST_ACCEPTED=""
    _AI_CURRENT_SUGGESTION=""
    POSTDISPLAY=""
    _ai_remove_ghost_highlight
    zle accept-line
}
zle -N _ai_voice_accept_line

# Bind Enter to voice-aware accept
bindkey '^M' _ai_voice_accept_line    # Enter

# Bind Ctrl+V for voice mode (Cmd+Ctrl doesn't produce a terminal sequence)
# Users can rebind this or use their speech-to-text tool's hotkey
bindkey '^X^V' _ai_enter_voice_mode   # Ctrl+X Ctrl+V

# ============================================
# Feature 2: Command Logging Hooks
# ============================================

# Log command start (runs before each command)
_ai_preexec() {
    # Skip if no command
    [[ -z "$1" ]] && return

    # Generate unique command ID (use seconds + random for uniqueness)
    _CLAI_COMMAND_ID="${CLAI_SESSION_ID}-$(date +%s)-${RANDOM}"
    # Store start time in milliseconds (macOS date doesn't support %N)
    _CLAI_COMMAND_START_TIME=$(($(date +%s) * 1000))
    _CLAI_LAST_COMMAND="$1"
    export CLAI_LAST_COMMAND="$_CLAI_LAST_COMMAND"

    # Fire and forget - log command start to daemon
    (clai-shim log-start \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --cwd="$PWD" \
        --command="$1" >/dev/null 2>&1 &)
}

# Log command end and update suggestion (runs after each command)
_ai_precmd() {
    local exit_code=$?

    # Log command completion if we have a pending command
    if [[ -n "$_CLAI_COMMAND_ID" ]]; then
        local end_time=$(($(date +%s) * 1000))
        local duration=$((end_time - _CLAI_COMMAND_START_TIME))

        # Fire and forget - log command end to daemon
        (clai-shim log-end \
            --session-id="$CLAI_SESSION_ID" \
            --command-id="$_CLAI_COMMAND_ID" \
            --exit-code="$exit_code" \
            --duration="$duration" >/dev/null 2>&1 &)

        # Clear command tracking state
        _CLAI_COMMAND_ID=""
        _CLAI_COMMAND_START_TIME=""
    fi

    # Show AI suggestion if available (buffer will be empty)
    _ai_update_suggestion
}

# Register hooks
autoload -U add-zsh-hook
add-zsh-hook preexec _ai_preexec
add-zsh-hook precmd _ai_precmd

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${pipestatus[1]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
# Note: In zsh, `history` is often aliased to `fc -l`. We must use the
# `function` keyword to prevent alias expansion during parsing (unalias
# runs at execution time, but aliases expand at parse time).
unalias history 2>/dev/null
function history {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to zsh's native history (fc -l)
        shift
        fc -l "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            echo "$output"
        else
            # Fall back to shell's native history
            fc -l "$@"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(fc -ln -1)}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(fc -ln -5 2>/dev/null | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}


# ============================================
# Feature 4a: TUI Picker (clai-picker)
# ============================================
# If clai-picker is on PATH, Up arrow and Alt+H open the full TUI picker.
# Exit codes: 0 = selection, 1 = cancel, 2 = fallback to native history.

# Brief user feedback (throttled) when picker actions can't run.
typeset -gi _CLAI_NOTIFY_LAST_TS=0
_clai_notify_throttled() {
    local msg="$1"
    local now=${EPOCHSECONDS:-0}
    if (( now - _CLAI_NOTIFY_LAST_TS >= 5 )); then
        _CLAI_NOTIFY_LAST_TS=$now
        zle -M "$msg"
    fi
}

_clai_supports_utf8() {
    # Prefer locale variables in order. If none are set, assume UTF-8.
    local value
    for value in "$LC_ALL" "$LC_CTYPE" "$LANG"; do
        if [[ -n "$value" ]]; then
            value="${value:l}"
            if [[ "$value" == *"utf-8"* || "$value" == *"utf8"* ]]; then
                return 0
            fi
            return 1
        fi
    done
    return 0
}

_clai_picker_brief_error() {
    local err="$1"
    local lower="${err:l}"
    if [[ "$lower" == *"rpc:"* || "$lower" == *"dial unix"* || "$lower" == *"no such file or directory"* || "$lower" == *"connection refused"* ]]; then
        echo "clai: daemon unavailable"
        return
    fi
    if [[ "$lower" == *"/dev/tty"* || "$lower" == *"requires a tty"* ]]; then
        echo "clai: picker requires a TTY"
        return
    fi
    echo "clai: picker failed"
}

_clai_has_tui_picker() {
    command -v clai-picker >/dev/null 2>&1
}

_clai_tui_picker_open() {
    if ! _clai_has_tui_picker; then
        _clai_notify_throttled "clai: clai-picker not installed"
        zle up-line-or-history
        return
    fi
    local result exit_code saved_buffer="$BUFFER" errfile errtxt
    _ai_clear_ghost_text
    errfile="$(mktemp -t clai-picker.XXXXXX 2>/dev/null || mktemp "/tmp/clai-picker.XXXXXX")"
    result=$(clai-picker history --query="$BUFFER" --session="$CLAI_SESSION_ID" --cwd="$PWD" 2>"$errfile")
    exit_code=$?
    if [[ -f "$errfile" ]]; then
        errtxt="$(<"$errfile")"
        rm -f "$errfile"
    fi
    if [[ $exit_code -eq 0 ]]; then
        # Clear ghost text before setting the new buffer.
        _ai_clear_ghost_text
        BUFFER="$result"
        CURSOR=${#BUFFER}
    elif [[ $exit_code -eq 2 ]]; then
        [[ -n "$errtxt" ]] && _clai_notify_throttled "$(_clai_picker_brief_error "$errtxt")"
        zle up-line-or-history
        return
    elif [[ -n "$errtxt" ]]; then
        _clai_notify_throttled "$(_clai_picker_brief_error "$errtxt")"
    fi
    # exit_code 1 = cancel, keep original buffer
    zle redisplay
}
zle -N _clai_tui_picker_open

_clai_tui_suggest_picker_open() {
    if ! _clai_has_tui_picker; then
        _clai_notify_throttled "clai: clai-picker not installed"
        return
    fi
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        return
    fi
    local result exit_code errfile errtxt
    _ai_clear_ghost_text
    errfile="$(mktemp -t clai-picker.XXXXXX 2>/dev/null || mktemp "/tmp/clai-picker.XXXXXX")"
    result=$(clai-picker suggest --query="$BUFFER" --session="$CLAI_SESSION_ID" --cwd="$PWD" 2>"$errfile")
    exit_code=$?
    if [[ -f "$errfile" ]]; then
        errtxt="$(<"$errfile")"
        rm -f "$errfile"
    fi
    if [[ $exit_code -eq 0 ]]; then
        _ai_clear_ghost_text
        BUFFER="$result"
        CURSOR=${#BUFFER}
        zle redisplay
        return
    fi
    # exit_code 1 = cancel, 2 = fallback, anything else = error
    if [[ $exit_code -ne 1 ]]; then
        if [[ -n "$errtxt" ]]; then
            _clai_notify_throttled "$(_clai_picker_brief_error "$errtxt")"
        else
            _clai_notify_throttled "clai: suggestion picker unavailable"
        fi
    fi
    zle redisplay
}
zle -N _clai_tui_suggest_picker_open

# ============================================
# Feature 4b: Suggestion + History Pickers
# ============================================
# - Tab opens suggestion picker
# - Up arrow opens TUI picker (or inline history picker as fallback)
# - Up/Down navigate while picker is open
# - Enter accepts selection (insert only)
# - Esc cancels and restores original buffer

_CLAI_PICKER_ITEMS=()
_CLAI_PICKER_INDEX=0
_CLAI_PICKER_ACTIVE=false
_CLAI_PICKER_MODE=""
_CLAI_PICKER_ORIG_BUFFER=""
_CLAI_PICKER_ORIG_CURSOR=0
_CLAI_PICKER_PAGE=0
_CLAI_PICKER_AT_END=false
_CLAI_HISTORY_SCOPE="session"

_clai_config_enabled() {
    local enabled
    enabled=$(clai config suggestions.enabled 2>/dev/null)
    [[ "$enabled" != "false" ]]
}

_clai_history_args() {
    # Output one argument per line to handle paths with spaces
    # Caller must use ${(f)...} to split on newlines
    case "$_CLAI_HISTORY_SCOPE" in
        session)
            echo "--session=$CLAI_SESSION_ID"
            ;;
        cwd)
            echo "--session=$CLAI_SESSION_ID"
            echo "--cwd=$PWD"
            ;;
        global)
            echo "--global"
            ;;
        *)
            echo "--session=$CLAI_SESSION_ID"
            ;;
    esac
}

_clai_picker_load() {
    local offset="${1:-0}"
    local -a items
    if [[ "$_CLAI_PICKER_MODE" == "suggest" ]]; then
        if [[ -n "$BUFFER" ]]; then
            items=(${(f)"$(clai suggest --format fzf --limit "$CLAI_MENU_LIMIT" "$BUFFER" 2>/dev/null)"})
        else
            # Intentional: with empty BUFFER, 'clai suggest' only returns the
            # single cached AI suggestion which isn't useful for a picker list.
            # Fall back to recent session history instead.
            items=(${(f)"$(clai history --limit "$CLAI_MENU_LIMIT" --offset "$offset" --session="$CLAI_SESSION_ID" 2>/dev/null)"})
        fi
    else
        local -a args
        args=(${(f)"$(_clai_history_args)"})
        if [[ -n "$BUFFER" ]]; then
            items=(${(f)"$(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" --offset "$offset" "$BUFFER" 2>/dev/null)"})
        else
            items=(${(f)"$(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" --offset "$offset" 2>/dev/null)"})
        fi
    fi

    # Deduplicate while preserving order (zsh unique flag)
    _CLAI_PICKER_ITEMS=("${(u)items[@]}")
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    # If fewer items returned than the limit, we've reached the end
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -lt $CLAI_MENU_LIMIT ]]; then
        _CLAI_PICKER_AT_END=true
    else
        _CLAI_PICKER_AT_END=false
    fi
    return 0
}

_clai_picker_render() {
    local menu_text=""
    local header="Suggestions"
    if [[ "$_CLAI_PICKER_MODE" == "history" ]]; then
        header="History (${_CLAI_HISTORY_SCOPE})"
    fi

    menu_text+=$'\n'"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    # Render items in array order: index 0 (newest) at top, closest to input.
    local count=${#_CLAI_PICKER_ITEMS[@]}
    local i=0
    while [[ $i -lt $count ]]; do
        local item="${_CLAI_PICKER_ITEMS[$i + 1]}"  # zsh 1-based
        if [[ $i -eq $_CLAI_PICKER_INDEX ]]; then
            menu_text+=$'\n'" â†’ $item"
        else
            menu_text+=$'\n'"   $item"
        fi
        ((i++))
    done
    POSTDISPLAY=""
    _ai_remove_ghost_highlight
    zle -M "$header (â†‘â†“, Enter, Ctrl+C):$menu_text"
}

_clai_picker_open() {
    local mode="$1"
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        return 1
    fi
    if ! _clai_config_enabled; then
        return 1
    fi

    _CLAI_PICKER_MODE="$mode"
    _CLAI_PICKER_ORIG_BUFFER="$BUFFER"
    _CLAI_PICKER_ORIG_CURSOR=$CURSOR
    _CLAI_PICKER_ACTIVE=true
    _CLAI_PICKER_INDEX=0
    _CLAI_PICKER_PAGE=0
    _CLAI_PICKER_AT_END=false

    if ! _clai_picker_load 0; then
        _CLAI_PICKER_ACTIVE=false
        return 1
    fi
    _clai_picker_render
}

_clai_picker_close() {
    _CLAI_PICKER_ACTIVE=false
    _CLAI_PICKER_ITEMS=()
    _CLAI_PICKER_INDEX=0
    _CLAI_PICKER_PAGE=0
    _CLAI_PICKER_AT_END=false
    _CLAI_PICKER_MODE=""
    zle -M ""
}

_clai_picker_cancel() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        BUFFER="$_CLAI_PICKER_ORIG_BUFFER"
        CURSOR=$_CLAI_PICKER_ORIG_CURSOR
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        _clai_picker_close
        _ai_update_suggestion
        zle redisplay
    fi
}

_clai_picker_accept() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX + 1]}"
        BUFFER="$selected"
        CURSOR=${#BUFFER}
        # Clear ghost text before closing picker and recalculating.
        _AI_CURRENT_SUGGESTION=""
        POSTDISPLAY=""
        _ai_remove_ghost_highlight
        _clai_picker_close
        _ai_update_suggestion
        zle redisplay
    else
        _ai_voice_accept_line
    fi
}

_clai_picker_up() {
    # Fast path: if picker is already open, navigate without external commands
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        _ai_clear_ghost_text
        local last_index=$((${#_CLAI_PICKER_ITEMS[@]} - 1))
        if [[ $_CLAI_PICKER_INDEX -lt $last_index ]]; then
            # Move up in the visual list (toward older items)
            ((_CLAI_PICKER_INDEX++))
            _clai_picker_render
        elif [[ "$_CLAI_PICKER_AT_END" != "true" ]]; then
            # At top of current page and more items exist â€” load next page
            ((_CLAI_PICKER_PAGE++))
            local offset=$((_CLAI_PICKER_PAGE * CLAI_MENU_LIMIT))
            if _clai_picker_load "$offset"; then
                # Place cursor at bottom after paging (newest item on new page)
                _CLAI_PICKER_INDEX=0
                local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX + 1]}"
                if [[ -n "$selected" ]]; then
                    BUFFER="$selected"
                    CURSOR=${#BUFFER}
                fi
                _clai_picker_render
            else
                # No more items â€” mark end and stay put
                _CLAI_PICKER_AT_END=true
                ((_CLAI_PICKER_PAGE--))
            fi
        fi
        # At end and at top: do nothing (no more items)
        return
    fi
    # Not in picker â€” check for double-tap to open picker, else navigate history.
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        _ai_up_line_or_history
        return
    fi

    # Double-tap detection: open picker only if two Up presses within 0.5s.
    # Guard: if EPOCHREALTIME is unavailable, skip double-tap and navigate history.
    if [[ -z "$EPOCHREALTIME" ]]; then
        _ai_up_line_or_history
        return
    fi
    local now=$EPOCHREALTIME
    local elapsed=$(( now - _CLAI_LAST_UP_TIME ))
    _CLAI_LAST_UP_TIME=$now

    if (( elapsed > _CLAI_DOUBLE_TAP_THRESHOLD )); then
        # Single tap â€” navigate history, keep ghost text
        _ai_up_line_or_history
        return
    fi

    # Double-tap confirmed â€” open picker
    if [[ "$CLAI_PICKER_OPEN_ON_EMPTY" != "true" && -z "$BUFFER" ]]; then
        _ai_up_line_or_history
        return
    fi
    if _clai_has_tui_picker; then
        _ai_clear_ghost_text
        _clai_tui_picker_open
        return
    fi
    if ! _clai_config_enabled; then
        zle up-line-or-history
        return
    fi
    _ai_clear_ghost_text
    _clai_picker_open history
}

_clai_picker_down() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        if [[ "$_CLAI_PICKER_MODE" == "history" && $_CLAI_PICKER_INDEX -le 0 ]]; then
            # Match native history UX: at the newest item, Down should return to
            # the original buffer (not stay stuck at the bottom of the picker).
            _clai_picker_cancel
            return
        fi
        if [[ $_CLAI_PICKER_INDEX -gt 0 ]]; then
            # Move down in the visual list (toward newer items)
            ((_CLAI_PICKER_INDEX--))
            _clai_picker_render
        fi
        # At bottom (index 0): do nothing
        return
    fi
    zle down-line-or-history
}

_clai_picker_suggest() {
    # When history picker is active, Tab cycles scopes instead of opening suggest
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        case "$_CLAI_HISTORY_SCOPE" in
            session) _CLAI_HISTORY_SCOPE="global" ;;
            *)       _CLAI_HISTORY_SCOPE="session" ;;
        esac
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
        return
    fi
    _clai_picker_open suggest || zle expand-or-complete
}

_clai_history_scope_session() {
    _CLAI_HISTORY_SCOPE="session"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: session"
    fi
}

_clai_history_scope_cwd() {
    _CLAI_HISTORY_SCOPE="cwd"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: cwd"
    fi
}

_clai_history_scope_global() {
    _CLAI_HISTORY_SCOPE="global"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_PAGE=0
        _CLAI_PICKER_AT_END=false
        _clai_picker_load 0 && _clai_picker_render
    else
        zle -M "History scope: global"
    fi
}

# Cancel picker or send-break (overrides default send-break for Ctrl+C/Ctrl+G)
_clai_picker_break() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        _clai_picker_cancel
        return
    fi
    _ai_clear_ghost_text
    zle .send-break
}

zle -N _clai_picker_suggest
zle -N _clai_picker_up
zle -N _clai_picker_down
zle -N _clai_picker_accept
zle -N _clai_history_scope_session
zle -N _clai_history_scope_cwd
zle -N _clai_history_scope_global
zle -N send-break _clai_picker_break

# Alt/Option+H opens TUI picker.
# '\eh' works when the terminal sends ESC for Alt (Linux, or macOS with
# "Use Option as Meta key" enabled). The literal 'Ë™' covers macOS
# Terminal.app and iTerm2 defaults where Option+H produces U+02D9.
bindkey '\eh' _clai_tui_picker_open
bindkey 'Ë™' _clai_tui_picker_open

# Alt/Option+S opens the suggestions TUI picker.
# '\es' works when the terminal sends ESC for Alt. The literal 'ÃŸ' covers
# common macOS defaults where Option+S produces U+00DF.
bindkey '\es' _clai_tui_suggest_picker_open
bindkey 'ÃŸ' _clai_tui_suggest_picker_open

# When up_arrow_opens_history is enabled:
# - trigger=single: Up opens TUI picker (fallback: native history)
# - trigger=double: Up uses native history; Up+Up within window opens picker.
if [[ "$CLAI_UP_ARROW_HISTORY" == "true" ]]; then
    typeset -gi _clai_last_up_ms=0
    typeset -gi _clai_window_ms="${CLAI_UP_ARROW_DOUBLE_WINDOW_MS:-250}"
    [[ "$_clai_window_ms" == <-> ]] || _clai_window_ms=250
    (( _clai_window_ms < 50 )) && _clai_window_ms=50
    (( _clai_window_ms > 1000 )) && _clai_window_ms=1000

    _clai_up_arrow_single() {
        if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
            zle up-line-or-history
            return
        fi

        if [[ "${CLAI_UP_ARROW_TRIGGER:-single}" == "double" ]]; then
            local -i _clai_now_ms _clai_delta_ms
            if [[ -n "${EPOCHREALTIME:-}" ]]; then
                _clai_now_ms=$(( EPOCHREALTIME * 1000 ))
            else
                _clai_now_ms=$(( EPOCHSECONDS * 1000 ))
            fi
            _clai_delta_ms=$(( _clai_now_ms - _clai_last_up_ms ))
            if (( _clai_last_up_ms > 0 && _clai_delta_ms >= 0 && _clai_delta_ms <= _clai_window_ms )); then
                _clai_last_up_ms=0
                if _clai_has_tui_picker; then
                    _clai_tui_picker_open
                    return
                fi
            fi
            _clai_last_up_ms=$_clai_now_ms
            zle up-line-or-history
            return
        fi

        if _clai_has_tui_picker; then
            _clai_tui_picker_open
        else
            zle up-line-or-history
        fi
    }
    _clai_up_arrow_double() {
        if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
            zle up-line-or-history
            zle up-line-or-history
            return
        fi
        if _clai_has_tui_picker; then
            _clai_tui_picker_open
            return
        fi
        zle up-line-or-history
        zle up-line-or-history
    }
    zle -N _clai_up_arrow_single
    zle -N _clai_up_arrow_double
    for _clai_km in emacs viins main; do
        bindkey -M "$_clai_km" '^[[A' _clai_up_arrow_single    # Up arrow (CSI mode)
        bindkey -M "$_clai_km" '^[OA' _clai_up_arrow_single    # Up arrow (application mode)
        # Ensure Down arrow still performs native history navigation in both keymaps.
        bindkey -M "$_clai_km" '^[[B' down-line-or-history
        bindkey -M "$_clai_km" '^[OB' down-line-or-history
        bindkey -M "$_clai_km" -r '^[[A^[[A'
        bindkey -M "$_clai_km" -r '^[OA^[OA'
    done
    if [[ "${CLAI_UP_ARROW_TRIGGER:-single}" == "double" ]]; then
        # Keep KEYTIMEOUT side effects local: preserve and restore after binding setup.
        typeset _clai_prev_keytimeout
        _clai_prev_keytimeout="${KEYTIMEOUT:-}"
        typeset -gi _clai_keytimeout_cs
        _clai_keytimeout_cs=$(( (_clai_window_ms + 9) / 10 ))
        (( _clai_keytimeout_cs < 1 )) && _clai_keytimeout_cs=1
        KEYTIMEOUT=$_clai_keytimeout_cs
        for _clai_km in emacs viins main; do
            bindkey -M "$_clai_km" '^[[A^[[A' _clai_up_arrow_double
            bindkey -M "$_clai_km" '^[OA^[OA' _clai_up_arrow_double
        done
        KEYTIMEOUT="$_clai_prev_keytimeout"
    fi
fi

# Ensure arrow keys work in both emacs and viins keymaps even when
# CLAI_UP_ARROW_HISTORY is disabled (some environments ship without defaults).
if [[ "$CLAI_UP_ARROW_HISTORY" != "true" ]]; then
    for _clai_km in emacs viins main; do
        bindkey -M "$_clai_km" '^[[A' up-line-or-history
        bindkey -M "$_clai_km" '^[OA' up-line-or-history
        bindkey -M "$_clai_km" '^[[B' down-line-or-history
        bindkey -M "$_clai_km" '^[OB' down-line-or-history
    done
fi

# ============================================
# Full Disable / Enable (clai off / clai on)
# ============================================

_clai_disable() {
    export CLAI_OFF=1

    # Restore default ZLE widgets (undo custom overrides)
    zle -A .self-insert self-insert
    zle -A .backward-delete-char backward-delete-char
    zle -A .backward-char backward-char
    zle -A .beginning-of-line beginning-of-line
    zle -A .end-of-line end-of-line
    zle -A .forward-char forward-char
    zle -A .bracketed-paste bracketed-paste
    zle -A .send-break send-break

    # Restore default keybindings
    for _clai_km in emacs viins main; do
        bindkey -M "$_clai_km" '^I' expand-or-complete
        bindkey -M "$_clai_km" '^M' accept-line
        bindkey -M "$_clai_km" '^[[A' up-line-or-history
        bindkey -M "$_clai_km" '^[OA' up-line-or-history
        bindkey -M "$_clai_km" -r '^[[A^[[A'
        bindkey -M "$_clai_km" -r '^[OA^[OA'
        bindkey -M "$_clai_km" '^[[B' down-line-or-history
        bindkey -M "$_clai_km" '^[OB' down-line-or-history
        bindkey -M "$_clai_km" '\e[1;3C' forward-word
    done
    bindkey -r '^X^V'
    bindkey -r '^Xs'
    bindkey -r '^Xd'
    bindkey -r '^Xg'
    bindkey -r '\eh'
    bindkey -r 'Ë™'
    bindkey -r '\es'
    bindkey -r 'ÃŸ'

    if [[ -n "${_CLAI_ORIG_KEYTIMEOUT:-}" ]]; then
        KEYTIMEOUT="$_CLAI_ORIG_KEYTIMEOUT"
    fi

    # Restore zsh-autosuggestions
    _clai_zsh_autosuggest_restore

    # Remove hooks
    add-zsh-hook -d preexec _ai_preexec
    add-zsh-hook -d precmd _ai_precmd

    # Clear ghost text
    POSTDISPLAY=""
    _ai_remove_ghost_highlight

    # Restore native history command
    unfunction history 2>/dev/null

    echo "clai disabled â€” native shell restored"
}

_clai_enable() {
    unset CLAI_OFF
    local _saved_session="$CLAI_SESSION_ID"
    _CLAI_REINIT=1
    eval "$(command clai init zsh)"
    unset _CLAI_REINIT
    # Preserve original session ID so history stays continuous
    export CLAI_SESSION_ID="$_saved_session"
    echo "clai enabled"
}

# Wrapper function: intercepts off/on to run shell-native disable/enable
clai() {
    case "$1" in
        off)
            command clai "$@"
            _clai_disable
            ;;
        on)
            command clai "$@"
            _clai_enable
            ;;
        *)
            command clai "$@"
            ;;
    esac
}

# ============================================
# Daemon Management
# ============================================

# Daemon control commands (Claude daemon for fast voice, started lazily on first use)
ai-daemon() {
    case "$1" in
        start)
            clai daemon start
            ;;
        stop)
            clai daemon stop
            ;;
        status)
            clai daemon status
            ;;
        restart)
            clai daemon stop
            clai daemon start
            ;;
        *)
            echo "Usage: ai-daemon {start|stop|status|restart}"
            echo "  Manages the background Claude daemon for fast voice responses"
            ;;
    esac
}

# ============================================
# Startup
# ============================================

# Cleanup function for shell exit
_clai_cleanup() {
    # Notify daemon session is ending
    clai-shim session-end --session-id="$CLAI_SESSION_ID" >/dev/null 2>&1 &!
}

if [[ -o interactive && -z "$_CLAI_REINIT" ]]; then
    # Notify daemon of new session (fire and forget)
    # Note: claid starts lazily via clai-shim -> ipc.NewClient() -> EnsureDaemon()
    (clai-shim session-start \
        --session-id="$CLAI_SESSION_ID" \
        --cwd="$PWD" \
        --shell=zsh >/dev/null 2>&1 &)

    # Import shell history on first init (fire and forget)
    # This is idempotent: --if-not-exists skips if already imported
    (clai-shim import-history \
        --shell="$CLAI_CURRENT_SHELL" \
        --if-not-exists >/dev/null 2>&1 &)

    trap '_clai_cleanup' EXIT HUP

    local short_id="${CLAI_SESSION_ID:0:8}"
    if _clai_supports_utf8; then
        printf '\033[2mðŸ¤– clai [%s] Alt+S suggestions | Alt+H history | ?"describe task"\033[0m\n' "$short_id"
    else
        echo "clai [$short_id] Alt+S suggestions | Alt+H history | ?\"describe task\""
    fi
fi
