# clai.fish - clai shell integration for Fish
# Generated by: clai init fish
#
# Features:
#   1. Suggestion picker on Tab
#   2. History picker on Up arrow
#   3. Error diagnosis with `run` wrapper (captures output for analysis)
#
# Configuration (set these BEFORE sourcing):
#   set -gx CLAI_AUTO_EXTRACT true

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
set -gx CLAI_CURRENT_SHELL fish

if not set -q CLAI_AUTO_EXTRACT
    set -gx CLAI_AUTO_EXTRACT true
end

if not set -q CLAI_CACHE
    set -gx CLAI_CACHE "$HOME/.cache/clai"
end

if not set -q CLAI_MENU_LIMIT
    set -gx CLAI_MENU_LIMIT 5
end
if not set -q CLAI_UP_ARROW_HISTORY
    set -gx CLAI_UP_ARROW_HISTORY {{CLAI_UP_ARROW_HISTORY}}
end
if not set -q CLAI_UP_ARROW_TRIGGER
    set -gx CLAI_UP_ARROW_TRIGGER {{CLAI_UP_ARROW_TRIGGER}}
end
if not set -q CLAI_UP_ARROW_DOUBLE_WINDOW_MS
    set -gx CLAI_UP_ARROW_DOUBLE_WINDOW_MS {{CLAI_UP_ARROW_DOUBLE_WINDOW_MS}}
end

# Ensure cache directory exists
mkdir -p $CLAI_CACHE

# Files
set -g _AI_SUGGEST_FILE "$CLAI_CACHE/suggestion"
set -g _AI_LAST_OUTPUT "$CLAI_CACHE/last_output"

# Disable native autosuggestions only when clai is enabled
# (leave native suggestions working when CLAI_OFF=1 or session-off)
if test "$CLAI_OFF" != "1"; and not test -f "$CLAI_CACHE/off"
    # Save the user's original autosuggestion setting before overriding
    if not set -q _clai_prev_autosuggestion
        set -g _clai_prev_autosuggestion (set -q fish_autosuggestion_enabled; and echo $fish_autosuggestion_enabled; or echo 1)
    end
    set -g fish_autosuggestion_enabled 0
end

function _clai_session_off
    test -f "$CLAI_CACHE/off"
end

# ============================================
# Feature 1: Command Suggestion
# ============================================

# Accept suggestion with custom keybinding
function _ai_accept_suggestion
    if test -s $_AI_SUGGEST_FILE
        set -l suggestion (cat $_AI_SUGGEST_FILE)
        if test -n "$suggestion"
            commandline -r $suggestion
            commandline -f end-of-line
            # Record accepted feedback (fire and forget)
            clai suggest-feedback --action=accepted --suggested="$suggestion" >/dev/null 2>&1 &
            disown %1 2>/dev/null
            # Clear the suggestion
            echo -n "" > $_AI_SUGGEST_FILE
            return
        end
    end
    # Default behavior: normal tab completion
    commandline -f complete
end

# Bind Alt+Enter to accept suggestion (Tab is used for completions in Fish)
for mode in default insert visual
    bind -M $mode \e\r _ai_accept_suggestion
end

# Clear suggestion with Escape (dismiss feedback)
function _ai_clear_suggestion
    if test -s $_AI_SUGGEST_FILE
        set -l suggestion (cat $_AI_SUGGEST_FILE)
        if test -n "$suggestion"
            # Record dismissed feedback (fire and forget)
            clai suggest-feedback --action=dismissed --suggested="$suggestion" >/dev/null 2>&1 &
            disown %1 2>/dev/null
        end
    end
    echo -n "" > $_AI_SUGGEST_FILE
    set -g _AI_VOICE_MODE false
    commandline -f repaint
end

# Unified Escape handler: cancel picker if active, otherwise clear suggestion
function _clai_escape
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        _clai_picker_cancel
    else
        _ai_clear_suggestion
    end
end
for mode in default insert visual
    bind -M $mode \e _clai_escape
end

# ============================================
# Feature 2a: TUI Picker (clai-picker)
# ============================================
# If clai-picker is on PATH, Up arrow and Alt+H open the full TUI picker.
# Exit codes: 0 = selection, 1 = cancel, 2 = fallback to native history.

# Brief user feedback (throttled) when picker actions can't run.
set -g _CLAI_NOTIFY_LAST_TS 0
function _clai_notify_throttled --argument-names msg
    set -l now (date +%s)
    if test -z "$_CLAI_NOTIFY_LAST_TS"
        set -g _CLAI_NOTIFY_LAST_TS 0
    end
    if test (math "$now - $_CLAI_NOTIFY_LAST_TS") -ge 5
        set -g _CLAI_NOTIFY_LAST_TS $now
        echo $msg 1>&2
    end
end

function _clai_picker_brief_error --argument-names err
    set -l lower (string lower -- $err)
    if string match -q "*rpc:*" -- $lower; or string match -q "*dial unix*" -- $lower; or string match -q "*no such file or directory*" -- $lower; or string match -q "*connection refused*" -- $lower
        echo "clai: daemon unavailable"
        return
    end
    if string match -q "*/dev/tty*" -- $lower; or string match -q "*requires a tty*" -- $lower
        echo "clai: picker requires a TTY"
        return
    end
    echo "clai: picker failed"
end

function _clai_has_tui_picker
    type -q clai-picker
end

function _clai_tui_picker_open
    if test "$CLAI_OFF" = "1"; or _clai_session_off
        commandline -f history-search-backward
        return
    end
    if not _clai_has_tui_picker
        _clai_notify_throttled "clai: clai-picker not installed"
        commandline -f history-search-backward
        return
    end
    set -l tmp (mktemp -t clai-picker.XXXXXX 2>/dev/null; or mktemp /tmp/clai-picker.XXXXXX)
    set -l result (clai-picker history --query=(commandline) --session="$CLAI_SESSION_ID" --cwd="$PWD" 2>$tmp)
    set -l exit_code $status
    set -l err ""
    if test -f $tmp
        set err (cat $tmp)
        rm -f $tmp
    end
    if test $exit_code -eq 0
        commandline -r -- $result
        commandline -f end-of-line
    else if test $exit_code -eq 2
        if test -n "$err"
            _clai_notify_throttled (_clai_picker_brief_error "$err")
        end
        commandline -f history-search-backward
        return
    else if test -n "$err"
        _clai_notify_throttled (_clai_picker_brief_error "$err")
    end
    # exit_code 1 = cancel, keep original buffer
    commandline -f repaint
end

function _clai_tui_suggest_picker_open
    if test "$CLAI_OFF" = "1"; or _clai_session_off
        return
    end
    if not _clai_has_tui_picker
        _clai_notify_throttled "clai: clai-picker not installed"
        commandline -f repaint
        return
    end
    set -l tmp (mktemp -t clai-picker.XXXXXX 2>/dev/null; or mktemp /tmp/clai-picker.XXXXXX)
    set -l result (clai-picker suggest --query=(commandline) --session="$CLAI_SESSION_ID" --cwd="$PWD" 2>$tmp)
    set -l exit_code $status
    set -l err ""
    if test -f $tmp
        set err (cat $tmp)
        rm -f $tmp
    end
    if test $exit_code -eq 0
        commandline -r -- $result
        commandline -f end-of-line
    else if test $exit_code -ne 1
        if test -n "$err"
            _clai_notify_throttled (_clai_picker_brief_error "$err")
        else
            _clai_notify_throttled "clai: suggestion picker unavailable"
        end
    end
    commandline -f repaint
end

# ============================================
# Feature 2b: Suggestion & History Pickers
# ============================================

set -g _CLAI_PICKER_ACTIVE false
set -g _CLAI_PICKER_MODE ""
set -g _CLAI_PICKER_INDEX 1
set -g _CLAI_PICKER_ORIG_BUFFER ""
set -g _CLAI_PICKER_ITEMS
set -g _CLAI_HISTORY_SCOPE session

set -g _CLAI_SUGGESTIONS_ENABLED ""

function _clai_config_enabled
    # Cache the config value on first call to avoid invoking clai on every keypress
    if test -z "$_CLAI_SUGGESTIONS_ENABLED"
        set -g _CLAI_SUGGESTIONS_ENABLED (clai config suggestions.enabled 2>/dev/null)
    end
    if test "$_CLAI_SUGGESTIONS_ENABLED" = "false"
        return 1
    end
    return 0
end

function _clai_history_args
    # Each argument on its own line so fish command-substitution splits correctly
    # (spaces in $PWD would break single-line echo splitting)
    switch $_CLAI_HISTORY_SCOPE
        case session
            echo "--session=$CLAI_SESSION_ID"
        case cwd
            echo "--session=$CLAI_SESSION_ID"
            echo "--cwd=$PWD"
        case global
            echo "--global"
        case '*'
            echo "--session=$CLAI_SESSION_ID"
    end
end

function _clai_dedup
    # Deduplicate a list preserving first-occurrence order
    # Usage: set -l unique (_clai_dedup $items)
    printf '%s\n' $argv | awk '!seen[$0]++'
end

function _clai_picker_load_suggest
    set -l current (commandline)
    set -l items
    if test -n "$current"
        set items (clai suggest --format fzf --limit $CLAI_MENU_LIMIT "$current" 2>/dev/null | string split '\n')
    else
        set items (clai history --session="$CLAI_SESSION_ID" --limit $CLAI_MENU_LIMIT 2>/dev/null | string split '\n')
    end
    if test (count $items) -eq 0
        return 1
    end
    set -g _CLAI_PICKER_ITEMS (_clai_dedup $items)
    return 0
end

function _clai_picker_load_history
    set -l args (_clai_history_args)
    set -l prefix (commandline)
    set -l items
    if test -n "$prefix"
        set items (clai history $args --limit $CLAI_MENU_LIMIT "$prefix" 2>/dev/null | string split '\n')
    else
        set items (clai history $args --limit $CLAI_MENU_LIMIT 2>/dev/null | string split '\n')
    end
    if test (count $items) -eq 0
        return 1
    end
    set -g _CLAI_PICKER_ITEMS (_clai_dedup $items)
    return 0
end

set -g _CLAI_PICKER_LINE_COUNT 0

function _clai_picker_render
    set -l header "Suggestions"
    if test "$_CLAI_PICKER_MODE" = "history"
        set header "History ($_CLAI_HISTORY_SCOPE)"
    end

    # Build menu lines
    set -l menu_lines "$header (â†‘â†“, Enter, Esc):" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    set -l i 1
    for item in $_CLAI_PICKER_ITEMS
        if test $i -eq $_CLAI_PICKER_INDEX
            set -a menu_lines " â†’ $item"
        else
            set -a menu_lines "   $item"
        end
        set i (math $i + 1)
    end

    set -g _CLAI_PICKER_LINE_COUNT (count $menu_lines)

    # Draw below command line using terminal escape sequences
    printf '\e[s' >&2              # save cursor position
    printf '\n\e[J' >&2            # newline + clear to end of screen
    for line in $menu_lines
        printf '%s\n' "$line" >&2
    end
    printf '\e[u' >&2              # restore cursor position
end

function _clai_picker_clear_menu
    if test $_CLAI_PICKER_LINE_COUNT -gt 0
        printf '\e[s' >&2          # save cursor
        printf '\n\e[J' >&2        # newline + clear to end of screen
        printf '\e[u' >&2          # restore cursor
        set -g _CLAI_PICKER_LINE_COUNT 0
    end
end

function _clai_picker_apply
    set -l selected $_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX]
    if test -n "$selected"
        commandline -r -- $selected
        commandline -f end-of-line
    end
    _clai_picker_render
end

function _clai_picker_close
    _clai_picker_clear_menu
    set -g _CLAI_PICKER_ACTIVE false
    set -g _CLAI_PICKER_MODE ""
    set -g _CLAI_PICKER_ITEMS
    set -g _CLAI_PICKER_INDEX 1
end

function _clai_picker_cancel
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        commandline -r -- $_CLAI_PICKER_ORIG_BUFFER
        commandline -f end-of-line
        _clai_picker_close
    end
end

function _clai_tab
    if test "$CLAI_OFF" = "1"; or _clai_session_off
        commandline -f complete
        return
    end
    if not _clai_config_enabled
        commandline -f complete
        return
    end
    # When history picker is active, Tab cycles scopes
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "history"
        switch $_CLAI_HISTORY_SCOPE
            case session
                set -g _CLAI_HISTORY_SCOPE global
            case '*'
                set -g _CLAI_HISTORY_SCOPE session
        end
        set -g _CLAI_PICKER_INDEX 1
        if _clai_picker_load_history
            _clai_picker_apply
        end
        return
    end
    # Suggestions picker is a fullscreen TUI on Alt/Option+S; keep Tab native.
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "suggest"
        _clai_picker_cancel
    end
    commandline -f complete
end

function _clai_history_up
    if test "$CLAI_OFF" = "1"; or _clai_session_off
        commandline -f history-search-backward
        return
    end
    # Try TUI picker first (when inline picker is not already active)
    if test "$_CLAI_PICKER_ACTIVE" != "true"; and _clai_has_tui_picker
        _clai_tui_picker_open
        return
    end
    if not _clai_config_enabled
        commandline -f history-search-backward
        return
    end
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "suggest"
        _clai_picker_prev
        return
    end
    if test "$_CLAI_PICKER_ACTIVE" != "true" -o "$_CLAI_PICKER_MODE" != "history"
        set -g _CLAI_PICKER_ORIG_BUFFER (commandline)
        set -g _CLAI_PICKER_MODE history
        set -g _CLAI_PICKER_INDEX 1
        set -g _CLAI_PICKER_ACTIVE true
        if not _clai_picker_load_history
            _clai_picker_close
            commandline -f history-search-backward
            return
        end
        _clai_picker_apply
        return
    end
    _clai_picker_next
end

function _clai_picker_down
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        if test "$_CLAI_PICKER_MODE" = "history"
            # Match native history UX: when the newest item is selected, Down
            # should return to the original buffer instead of wrapping.
            if test $_CLAI_PICKER_INDEX -le 1
                _clai_picker_cancel
                return
            end
            _clai_picker_prev
        else
            _clai_picker_next
        end
        return
    end
    commandline -f history-search-forward
end

function _clai_picker_next
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        set -l item_count (count $_CLAI_PICKER_ITEMS)
        if test $item_count -eq 0
            return
        end
        if test $_CLAI_PICKER_INDEX -lt $item_count
            set -g _CLAI_PICKER_INDEX (math $_CLAI_PICKER_INDEX + 1)
        else
            set -g _CLAI_PICKER_INDEX 1
        end
        _clai_picker_apply
    end
end

function _clai_picker_prev
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        set -l item_count (count $_CLAI_PICKER_ITEMS)
        if test $item_count -eq 0
            return
        end
        if test $_CLAI_PICKER_INDEX -gt 1
            set -g _CLAI_PICKER_INDEX (math $_CLAI_PICKER_INDEX - 1)
        else
            set -g _CLAI_PICKER_INDEX $item_count
        end
        _clai_picker_apply
    end
end

function _clai_history_scope_session
    set -g _CLAI_HISTORY_SCOPE session
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "history"
        set -g _CLAI_PICKER_INDEX 1
        _clai_picker_load_history; and _clai_picker_apply
    end
end

function _clai_history_scope_cwd
    set -g _CLAI_HISTORY_SCOPE cwd
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "history"
        set -g _CLAI_PICKER_INDEX 1
        _clai_picker_load_history; and _clai_picker_apply
    end
end

function _clai_history_scope_global
    set -g _CLAI_HISTORY_SCOPE global
    if test "$_CLAI_PICKER_ACTIVE" = "true" -a "$_CLAI_PICKER_MODE" = "history"
        set -g _CLAI_PICKER_INDEX 1
        _clai_picker_load_history; and _clai_picker_apply
    end
end

# Picker keybindings (inline picker controls + scope switching).
for mode in default insert visual
    bind -M $mode \t _clai_tab
    bind -M $mode \e\[B _clai_picker_down
    bind -M $mode \eOB _clai_picker_down
    bind -M $mode \cxs _clai_history_scope_session
    bind -M $mode \cxd _clai_history_scope_cwd
    bind -M $mode \cxg _clai_history_scope_global
end

# Alt/Option+H opens TUI picker.
# \eh works when the terminal sends ESC for Alt. The literal Ë™ covers
# macOS Terminal.app/iTerm2 defaults where Option+H produces U+02D9.
for mode in default insert visual
    bind -M $mode \eh _clai_tui_picker_open
    bind -M $mode Ë™ _clai_tui_picker_open
end

# Alt/Option+S opens the suggestions TUI picker.
for mode in default insert visual
    bind -M $mode \es _clai_tui_suggest_picker_open
    bind -M $mode ÃŸ _clai_tui_suggest_picker_open
end

# When up_arrow_opens_history is enabled:
# - trigger=single: Up opens TUI picker (fallback: native history)
# - trigger=double: Up uses native history; Up+Up within window opens picker.
if test "$CLAI_UP_ARROW_HISTORY" = "true"
    function _clai_up_arrow_single
        if test "$CLAI_OFF" = "1"; or _clai_session_off
            commandline -f history-search-backward
            return
        end

        if test "$CLAI_UP_ARROW_TRIGGER" = "double"
            commandline -f history-search-backward
            return
        end

        if _clai_has_tui_picker
            _clai_tui_picker_open
        else
            commandline -f history-search-backward
        end
    end

    function _clai_up_arrow_double
        if test "$CLAI_OFF" = "1"; or _clai_session_off
            commandline -f history-search-backward
            commandline -f history-search-backward
            return
        end
        if _clai_has_tui_picker
            _clai_tui_picker_open
            return
        end
        commandline -f history-search-backward
        commandline -f history-search-backward
    end

    for mode in default insert visual
        bind -M $mode \e\[A _clai_up_arrow_single
        bind -M $mode \eOA _clai_up_arrow_single
    end
    if test "$CLAI_UP_ARROW_TRIGGER" = "double"
        if not set -q _CLAI_ORIG_SEQUENCE_KEY_DELAY_MS
            if set -q fish_sequence_key_delay_ms
                set -g _CLAI_ORIG_SEQUENCE_KEY_DELAY_MS $fish_sequence_key_delay_ms
            else
                set -g _CLAI_ORIG_SEQUENCE_KEY_DELAY_MS __clai_unset__
            end
        end
        set -l window $CLAI_UP_ARROW_DOUBLE_WINDOW_MS
        if not string match -qr '^[0-9]+$' -- "$window"
            set window 250
        end
        if test $window -lt 50
            set window 50
        end
        if test $window -gt 1000
            set window 1000
        end
        set -g fish_sequence_key_delay_ms $window

        # Keep an explicit default-mode binding (no -M) so the generated script
        # works even if users don't have mode bindings, and so init tests can
        # validate the presence of the sequence binding.
        bind \e\[A\e\[A _clai_up_arrow_double
        bind \eOA\eOA _clai_up_arrow_double

        for mode in default insert visual
            bind -M $mode \e\[A\e\[A _clai_up_arrow_double
            bind -M $mode \eOA\eOA _clai_up_arrow_double
        end
    else
        for mode in default insert visual
            bind -M $mode -e \e\[A\e\[A 2>/dev/null
            bind -M $mode -e \eOA\eOA 2>/dev/null
        end
    end
end

# ============================================
# Feature 3: Voice Mode
# ============================================
# When activated, the next Enter press will run the input through voice conversion

set -g _AI_VOICE_MODE false

function _ai_enter_voice_mode
    set -g _AI_VOICE_MODE true
    commandline -f repaint
end

function _ai_voice_execute
    # If picker is open, accept the current selection (don't execute)
    if test "$_CLAI_PICKER_ACTIVE" = "true"
        # Record accepted feedback for picker selection (fire and forget)
        set -l selected $_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX]
        if test -n "$selected"
            clai suggest-feedback --action=accepted --suggested="$selected" >/dev/null 2>&1 &
            disown %1 2>/dev/null
        end
        _clai_picker_close
        return
    end

    set -l current_cmd (commandline)

    # Check for ? prefix (natural language input marker)
    if string match -q '\\?*' -- $current_cmd
        and test (string length -- $current_cmd) -gt 1
        # Remove the ? prefix and any leading space
        set -l nl_input (string replace -r '^\\?\\s*' '' -- $current_cmd)
        commandline -r ""

        echo "? $nl_input"
        set -l cmd (clai voice "$nl_input" 2>/dev/null)
        if test -n "$cmd"
            echo "â†’ $cmd"
            # Put command in buffer for user to review
            commandline -r $cmd
            commandline -f end-of-line
        end
        return
    end

    # Check for explicit voice mode
    if test "$_AI_VOICE_MODE" = "true"
        and test -n "$current_cmd"
        set -g _AI_VOICE_MODE false
        commandline -r ""

        echo "? $current_cmd"
        set -l cmd (clai voice "$current_cmd" 2>/dev/null)
        if test -n "$cmd"
            echo "â†’ $cmd"
            # Put command in buffer for user to review
            commandline -r $cmd
            commandline -f end-of-line
        end
        return
    end

    # Normal execute
    set -g _AI_VOICE_MODE false
    _clai_picker_clear_menu
    commandline -f execute
end

# Show voice mode indicator or suggestion in right prompt
function fish_right_prompt
    if test "$_AI_VOICE_MODE" = "true"
        set_color magenta
        echo -n "ðŸŽ¤ Voice mode"
        set_color normal
        return
    end

    set -l current (commandline)
    if test -n "$current"
        # Have input - get suggestion for prefix
        set -l suggestion (clai suggest --format fzf --limit 1 "$current" 2>/dev/null)
        if test -n "$suggestion" -a "$suggestion" != "$current"
            set_color brblack
            echo -n "($current â†’ $suggestion)"
            set_color normal
        end
    else if test -s $_AI_SUGGEST_FILE
        # No input - show cached AI suggestion
        set -l suggestion (cat $_AI_SUGGEST_FILE)
        if test -n "$suggestion"
            set_color brblack
            echo -n "($suggestion)"
            set_color normal
        end
    end
end

# Bind Ctrl+X Ctrl+V to enter voice mode
bind \cx\cv _ai_enter_voice_mode

# Bind Enter to voice-aware execute
bind \r _ai_voice_execute


# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
function run
    # Run command, capture output, pass through clai extract
    $argv 2>&1 | clai extract
    set -l exit_code $pipestatus[1]

    # Auto-diagnose if command failed
    if test $exit_code -ne 0
        echo ""
        set_color yellow
        echo "âš¡ Analyzing error..."
        set_color normal
        clai diagnose "$argv" "$exit_code" 2>/dev/null
    end

    return $exit_code
end

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
set -gx CLAI_SESSION_ID "{{CLAI_SESSION_ID}}"

# ============================================
# Command Logging (for history daemon)
# ============================================
# Track command execution for session-aware history

set -g _CLAI_COMMAND_ID ""
set -g _CLAI_COMMAND_START_TIME ""

# Log command start (runs before each command)
function _clai_preexec --on-event fish_preexec
    # Skip if clai is disabled
    if test "$CLAI_OFF" = "1"; or _clai_session_off
        return
    end

    # Skip if no session ID
    if test -z "$CLAI_SESSION_ID"
        return
    end

    set -l cmd $argv[1]

    # Skip empty commands
    if test -z "$cmd"
        return
    end

    # Generate unique command ID
    set -g _CLAI_COMMAND_ID "$CLAI_SESSION_ID-"(date +%s)"-"(random)
    # Store start time in milliseconds. Use nanoseconds if available.
    # On macOS/BSD, date +%s%N may output a literal trailing "N".
    set -l _ns (command date +%s%N 2>/dev/null)
    if string match -rq '^[0-9]+$' -- $_ns
        set -g _CLAI_COMMAND_START_TIME (math $_ns / 1000000)
    else
        set -g _CLAI_COMMAND_START_TIME (math (command date +%s) \* 1000)
    end

    # Export last command for child processes (used to suppress suggesting it again).
    set -gx CLAI_LAST_COMMAND "$cmd"

    # Fire and forget - log command start to daemon
    clai-shim log-start --session-id="$CLAI_SESSION_ID" --command-id="$_CLAI_COMMAND_ID" --cwd="$PWD" --command="$cmd" >/dev/null 2>&1 &
    disown %1 2>/dev/null
end

# Log command end (runs after each command)
function _clai_postexec --on-event fish_postexec
    set -l exit_code $status

    # Skip if no pending command
    if test -z "$_CLAI_COMMAND_ID"
        return
    end

    # Calculate end time in milliseconds. Use nanoseconds if available (GNU coreutils).
    set -l end_time
    set -l _ns (command date +%s%N 2>/dev/null)
    if string match -rq '^[0-9]+$' -- $_ns
        set end_time (math $_ns / 1000000)
    else
        set end_time (math (command date +%s) \* 1000)
    end
    set -l duration (math $end_time - $_CLAI_COMMAND_START_TIME)

    # Fire and forget - log command end to daemon
    clai-shim log-end --session-id="$CLAI_SESSION_ID" --command-id="$_CLAI_COMMAND_ID" --exit-code="$exit_code" --duration="$duration" >/dev/null 2>&1 &
    disown %1 2>/dev/null

    # Clear command tracking state
    set -g _CLAI_COMMAND_ID ""
    set -g _CLAI_COMMAND_START_TIME ""
end

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
function history --wraps=history
    if test (count $argv) -gt 0
        switch $argv[1]
            case '--global' '-g'
                # Pass through to builtin history (remove the --global flag)
                builtin history $argv[2..-1]
                return
            case '--help' '-h'
                echo "Usage: history [options] [query]"
                echo ""
                echo "Shows command history (session-specific if available, else shell history)."
                echo ""
                echo "Options:"
                echo "  -g, --global    Always use shell's native history"
                echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
                echo "  --cwd PATH      Filter by working directory"
                echo ""
                echo "Examples:"
                echo "  history              # Show session or shell history"
                echo "  history git          # Filter to git commands"
                echo "  history --global     # Force shell's native history"
                return
        end
    end
    # Try clai session history first, fall back to shell history
    set -l output (clai history --session="$CLAI_SESSION_ID" $argv 2>/dev/null)
    if test -n "$output" -a "$output" != "*No command*"
        echo "$output"
    else
        # Fall back to shell's native history
        builtin history $argv
    end
end

# Manually diagnose last command
function ai-fix
    if test (count $argv) -gt 0
        set cmd $argv[1]
    else
        set cmd (builtin history --max=1)
    end
    clai diagnose "$cmd" "1"
end

# Ask Claude anything with terminal context
function ai
    if test (count $argv) -eq 0
        echo "Usage: ai \"your question\""
        return 1
    end

    set -l recent_cmds (builtin history --max=5 | string join ';')
    clai ask --context "$recent_cmds" $argv
end

# Convert voice/natural language to terminal command
function voice
    if test (count $argv) -eq 0
        echo "Usage: voice \"natural language description\""
        return 1
    end

    clai voice $argv
end

# ============================================
# Full Disable / Enable (clai off / clai on)
# ============================================

function _clai_disable
    set -gx CLAI_OFF 1

    # Restore default keybindings
    for mode in default insert visual
        bind -M $mode \t complete
        bind -M $mode \e\[A history-search-backward
        bind -M $mode \eOA history-search-backward
        bind -M $mode \e\[B history-search-forward
        bind -M $mode \eOB history-search-forward
        bind -M $mode \r execute

        bind -M $mode -e \e\[A\e\[A 2>/dev/null
        bind -M $mode -e \eOA\eOA 2>/dev/null

        # Remove custom keybindings
        bind -M $mode \e ''
        bind -M $mode \e\r ''
        bind -M $mode \eh ''
        bind -M $mode Ë™ ''
        bind -M $mode \cx\cv ''
        bind -M $mode \cxs ''
        bind -M $mode \cxd ''
        bind -M $mode \cxg ''
        bind -M $mode \e\[B ''
        bind -M $mode \eOB ''
    end

    if set -q _CLAI_ORIG_SEQUENCE_KEY_DELAY_MS
        if test "$_CLAI_ORIG_SEQUENCE_KEY_DELAY_MS" = "__clai_unset__"
            set -ge fish_sequence_key_delay_ms
        else
            set -g fish_sequence_key_delay_ms $_CLAI_ORIG_SEQUENCE_KEY_DELAY_MS
        end
    end

    # Restore native autosuggestions to their prior state
    if set -q _clai_prev_autosuggestion
        set -g fish_autosuggestion_enabled $_clai_prev_autosuggestion
        set -ge _clai_prev_autosuggestion
    else
        set -g fish_autosuggestion_enabled 1
    end

    # Remove custom fish_right_prompt and history wrapper
    functions -e fish_right_prompt
    functions -e history

    echo "clai disabled â€” native shell restored"
end

function _clai_enable
    set -ge CLAI_OFF
    set -l _saved_session $CLAI_SESSION_ID
    set -g _CLAI_REINIT 1
    command clai init fish | source
    set -ge _CLAI_REINIT
    # Preserve original session ID so history stays continuous
    set -gx CLAI_SESSION_ID $_saved_session
    echo "clai enabled"
end

# Wrapper function: intercepts off/on to run shell-native disable/enable
function clai --wraps=clai
    switch $argv[1]
        case off
            command clai $argv
            _clai_disable
        case on
            command clai $argv
            _clai_enable
        case '*'
            command clai $argv
    end
end

# ============================================
# Startup Message
# ============================================

if status is-interactive; and not set -q _CLAI_REINIT
    # Register session with daemon (fire and forget)
    # This notifies the daemon of the new shell session
    clai-shim session-start --session-id="$CLAI_SESSION_ID" --cwd="$PWD" --shell="$CLAI_CURRENT_SHELL" >/dev/null 2>&1 &
    disown %1 2>/dev/null

    # Import shell history on first init (fire and forget)
    # This is idempotent: --if-not-exists skips if already imported
    clai-shim import-history --shell="$CLAI_CURRENT_SHELL" --if-not-exists >/dev/null 2>&1 &
    disown %1 2>/dev/null

    set -l short_id (string sub -l 8 -- $CLAI_SESSION_ID)
    set -l locale ""
    if set -q LC_ALL
        set locale $LC_ALL
    else if set -q LC_CTYPE
        set locale $LC_CTYPE
    else if set -q LANG
        set locale $LANG
    end

    set -l supports_utf8 1
    set -l lower (string lower -- (string trim -- $locale))
    if test -n "$lower"
        if string match -q "*utf-8*" -- $lower; or string match -q "*utf8*" -- $lower
            set supports_utf8 1
        else
            set supports_utf8 0
        end
    end

    if test "$supports_utf8" -eq 1
        printf '\e[2mðŸ¤– clai [%s] Alt+S suggestions | Alt+H history | ?"describe task"\e[0m\n' "$short_id"
    else
        echo "clai [$short_id] Alt+S suggestions | Alt+H history | ?\"describe task\""
    end
end
