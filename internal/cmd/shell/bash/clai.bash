# clai.bash - clai shell integration for Bash
# Generated by: clai init bash
#
# Features:
#   1. Suggestion picker on Tab (menu-complete)
#   2. History picker on Up arrow
#   3. Error diagnosis with `run` wrapper (captures output for analysis)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_EXTRACT=true    # Auto-extract commands (default: true)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=bash

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# Session-level disable flag
_clai_session_off() {
    [[ -f "$CLAI_CACHE/off" ]]
}

# ============================================
# Feature 1: Enhanced Tab Completion
# ============================================
# Adds clai history suggestions to Tab completion menu
# Our suggestions appear first, followed by defaults

# Portable alternative to mapfile for Bash 3.2 (macOS default)
# Usage: _clai_read_lines arrayname < <(command)
_clai_read_lines() {
    local _varname="$1"
    eval "$_varname=()"
    local _line
    while IFS= read -r _line; do
        eval "$_varname+=(\"\$_line\")"
    done
}

_clai_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"

    # Only enhance first word (command) completion
    if [[ $COMP_CWORD -eq 0 && -n "$cur" ]]; then
        local -a suggestions
        if [[ "$CLAI_OFF" != "1" ]] && ! _clai_session_off; then
            if ((BASH_VERSINFO[0] >= 4)); then
                mapfile -t suggestions < <(clai suggest --limit "$CLAI_MENU_LIMIT" "$cur" 2>/dev/null)
            else
                _clai_read_lines suggestions < <(clai suggest --limit "$CLAI_MENU_LIMIT" "$cur" 2>/dev/null)
            fi
        fi

        # Get default command completions
        local -a defaults
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t defaults < <(compgen -c -- "$cur" 2>/dev/null | head -20)
        else
            _clai_read_lines defaults < <(compgen -c -- "$cur" 2>/dev/null | head -20)
        fi

        COMPREPLY=("${suggestions[@]}" "${defaults[@]}")

        # Deduplicate while preserving order
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t COMPREPLY < <(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++')
        else
            local -a _deduped
            _clai_read_lines _deduped < <(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++')
            COMPREPLY=("${_deduped[@]}")
        fi
    else
        # For arguments, use default file completion
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t COMPREPLY < <(compgen -f -- "$cur")
        else
            _clai_read_lines COMPREPLY < <(compgen -f -- "$cur")
        fi
    fi
}

# Register completion for common commands
# Note: complete -D (default completion) requires bash 4.0+
if ((BASH_VERSINFO[0] >= 4)); then
    complete -o bashdefault -o default -F _clai_completion -D
else
    # For compatibility with bash 3.2 (macOS default), register specific commands
    complete -F _clai_completion git npm yarn docker kubectl make go cargo python pip
fi

# Enable menu-complete cycling on Tab
bind "set show-all-if-ambiguous on"
bind '"\t": menu-complete'

# ============================================
# Feature 1b: History Picker (Up Arrow)
# ============================================

_CLAI_PICKER_ACTIVE=false
_CLAI_PICKER_MODE=""
_CLAI_PICKER_INDEX=0
_CLAI_PICKER_ORIG_LINE=""
_CLAI_PICKER_ITEMS=()
_CLAI_HISTORY_SCOPE="session"
_CLAI_FALLBACK_ACTIVE=false
_CLAI_FALLBACK_INDEX=0
_CLAI_FALLBACK_ORIG_LINE=""
_CLAI_FALLBACK_ITEMS=()

_clai_fallback_reset() {
    _CLAI_FALLBACK_ACTIVE=false
    _CLAI_FALLBACK_INDEX=0
    _CLAI_FALLBACK_ORIG_LINE=""
    _CLAI_FALLBACK_ITEMS=()
}

_clai_fallback_load_history() {
    local -a entries
    if ((BASH_VERSINFO[0] >= 4)); then
        mapfile -t entries < <(history | sed -E 's/^ *[0-9]+[[:space:]]+//')
    else
        _clai_read_lines entries < <(history | sed -E 's/^ *[0-9]+[[:space:]]+//')
    fi

    _CLAI_FALLBACK_ITEMS=()
    local entry
    for entry in "${entries[@]}"; do
        if [[ -n "$entry" ]]; then
            _CLAI_FALLBACK_ITEMS+=("$entry")
        fi
    done

    if [[ ${#_CLAI_FALLBACK_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    return 0
}

_clai_fallback_apply() {
    local selected="${_CLAI_FALLBACK_ITEMS[$_CLAI_FALLBACK_INDEX]}"
    if [[ -n "$selected" ]]; then
        READLINE_LINE="$selected"
        READLINE_POINT=${#READLINE_LINE}
    fi
}

_clai_fallback_history_up() {
    if [[ "$_CLAI_FALLBACK_ACTIVE" != "true" ]]; then
        if ! _clai_fallback_load_history; then
            return 0
        fi
        _CLAI_FALLBACK_ORIG_LINE="$READLINE_LINE"
        _CLAI_FALLBACK_INDEX=$((${#_CLAI_FALLBACK_ITEMS[@]} - 1))
        _CLAI_FALLBACK_ACTIVE=true
        _clai_fallback_apply
        return 0
    fi

    if [[ $_CLAI_FALLBACK_INDEX -gt 0 ]]; then
        ((_CLAI_FALLBACK_INDEX--))
    else
        _CLAI_FALLBACK_INDEX=0
    fi
    _clai_fallback_apply
}

_clai_fallback_history_down() {
    if [[ "$_CLAI_FALLBACK_ACTIVE" != "true" ]]; then
        return 0
    fi

    if [[ $_CLAI_FALLBACK_INDEX -lt $((${#_CLAI_FALLBACK_ITEMS[@]} - 1)) ]]; then
        ((_CLAI_FALLBACK_INDEX++))
        _clai_fallback_apply
        return 0
    fi

    READLINE_LINE="$_CLAI_FALLBACK_ORIG_LINE"
    READLINE_POINT=${#READLINE_LINE}
    _clai_fallback_reset
}

_clai_history_args() {
    # Each argument on its own line so newline-based splitting works
    # correctly even when $PWD contains spaces.
    case "$_CLAI_HISTORY_SCOPE" in
        session)
            echo "--session=$CLAI_SESSION_ID"
            ;;
        cwd)
            echo "--session=$CLAI_SESSION_ID"
            echo "--cwd=$PWD"
            ;;
        global)
            echo "--global"
            ;;
        *)
            echo "--session=$CLAI_SESSION_ID"
            ;;
    esac
}

_clai_picker_load_history() {
    local -a args
    local IFS=$'\n'
    args=($(_clai_history_args))
    unset IFS
    if ((BASH_VERSINFO[0] >= 4)); then
        mapfile -t _CLAI_PICKER_ITEMS < <(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" "$READLINE_LINE" 2>/dev/null)
    else
        _clai_read_lines _CLAI_PICKER_ITEMS < <(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" "$READLINE_LINE" 2>/dev/null)
    fi
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    return 0
}

_clai_picker_apply() {
    local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX]}"
    if [[ -n "$selected" ]]; then
        READLINE_LINE="$selected"
        READLINE_POINT=${#READLINE_LINE}
    fi
}

_clai_history_up() {
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
            _clai_picker_cancel
        fi
        _clai_fallback_history_up
        return 0
    fi
    if [[ "$_CLAI_FALLBACK_ACTIVE" == "true" ]]; then
        _clai_fallback_reset
    fi
    if [[ "$_CLAI_PICKER_ACTIVE" != "true" || "$_CLAI_PICKER_MODE" != "history" ]]; then
        _CLAI_PICKER_ORIG_LINE="$READLINE_LINE"
        _CLAI_PICKER_MODE="history"
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_ACTIVE=true
        if ! _clai_picker_load_history; then
            _CLAI_PICKER_ACTIVE=false
            return 0
        fi
        _clai_picker_apply
        return 0
    fi

    if [[ $_CLAI_PICKER_INDEX -lt $((${#_CLAI_PICKER_ITEMS[@]} - 1)) ]]; then
        ((_CLAI_PICKER_INDEX++))
    else
        _CLAI_PICKER_INDEX=0
    fi
    _clai_picker_apply
}

_clai_history_down() {
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
            _clai_picker_cancel
        fi
        _clai_fallback_history_down
        return 0
    fi
    if [[ "$_CLAI_FALLBACK_ACTIVE" == "true" ]]; then
        _clai_fallback_reset
    fi
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        if [[ $_CLAI_PICKER_INDEX -gt 0 ]]; then
            ((_CLAI_PICKER_INDEX--))
        else
            _CLAI_PICKER_INDEX=$((${#_CLAI_PICKER_ITEMS[@]} - 1))
        fi
        _clai_picker_apply
    fi
}

_clai_picker_cancel() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        READLINE_LINE="$_CLAI_PICKER_ORIG_LINE"
        READLINE_POINT=${#READLINE_LINE}
        _CLAI_PICKER_ACTIVE=false
        _CLAI_PICKER_MODE=""
        _CLAI_PICKER_ITEMS=()
        _CLAI_PICKER_INDEX=0
    fi
}

_clai_history_scope_session() {
    _CLAI_HISTORY_SCOPE="session"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

_clai_history_scope_cwd() {
    _CLAI_HISTORY_SCOPE="cwd"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

_clai_history_scope_global() {
    _CLAI_HISTORY_SCOPE="global"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

# Bindings: Up/Down for history picker, Ctrl+G cancels, Ctrl+x s/d/g switches scope
#
# Arrow keys: bash 3.2 (macOS default) doesn't support `bind -x` with escape
# sequences â€” it fails with "cannot find keymap for command". Work around by
# using a readline macro to translate arrow escapes to Ctrl-X prefixed
# sequences, then bind those with -x.
bind '"\e[A": "\C-x\C-p"'
bind '"\e[B": "\C-x\C-n"'
bind -x '"\C-x\C-p": _clai_history_up'
bind -x '"\C-x\C-n": _clai_history_down'
bind -x '"\C-g": _clai_picker_cancel'
bind -x '"\C-xs": _clai_history_scope_session'
bind -x '"\C-xd": _clai_history_scope_cwd'
bind -x '"\C-xg": _clai_history_scope_global'

# Show AI suggestion in prompt when available (for AI-generated suggestions)
_ai_show_suggestion() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion
        suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            echo -e "\033[38;5;242m($suggestion) - use 'accept' to run\033[0m"
        fi
    fi
}

# Accept AI suggestion command
accept() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            # Clear suggestion
            > "$_AI_SUGGEST_FILE"
            # Execute the suggestion
            echo -e "\033[2mRunning: $suggestion\033[0m"
            eval "$suggestion"
            return $?
        fi
    fi
    echo "No suggestion available"
    return 1
}

# Clear suggestion
clear-suggestion() {
    > "$_AI_SUGGEST_FILE"
    echo "Suggestion cleared"
}

# ============================================
# Feature 2: Prompt Hook
# ============================================

# Check result after each command
_ai_prompt_command() {
    # Show any suggestions
    _ai_show_suggestion
}

# Append to existing PROMPT_COMMAND
if [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="_ai_prompt_command"
else
    PROMPT_COMMAND="_ai_prompt_command; $PROMPT_COMMAND"
fi

# ============================================
# Feature 3: Natural Language to Command (? prefix)
# ============================================
# Lines starting with ? are treated as natural language input
# Example: ?list all files â†’ ls -la

# Check for ? prefix and convert to command
_ai_check_nl_prefix() {
    local cmd="$1"
    if [[ "$cmd" == '?'* && ${#cmd} -gt 1 ]]; then
        local nl_input="${cmd#\?}"         # Remove the ? prefix
        nl_input="${nl_input## }"          # Remove leading space if any

        echo "? $nl_input"
        local result
        result=$(clai voice "$nl_input" 2>/dev/null)
        if [[ -n "$result" ]]; then
            echo "â†’ $result"
            # Cache for 'accept' command
            echo "$result" > "$_AI_SUGGEST_FILE"
            echo -e "\033[2mUse 'accept' to run, or copy the command above\033[0m"
        fi
        return 0  # Handled
    fi
    return 1  # Not a natural language command
}

# Hook into DEBUG trap to catch ? prefix before execution
# Note: extdebug must be enabled for the trap to block command execution
_ai_debug_trap() {
    # Check for natural language prefix first
    if _ai_check_nl_prefix "$BASH_COMMAND"; then
        # Prevent the original command from running (requires extdebug)
        return 1
    fi
    return 0
}

# Save current extdebug state and enable it for ? prefix blocking.
# Side effects: extdebug causes DEBUG/RETURN/ERR traps to be inherited by
# shell functions, command substitutions, and subshells. This is required
# for the ? prefix interception (returning 1 from DEBUG trap skips the
# command). The original state is saved and restored in _clai_cleanup.
_AI_EXTDEBUG_WAS_ON=false
if shopt -q extdebug; then
    _AI_EXTDEBUG_WAS_ON=true
fi
shopt -s extdebug

trap '_ai_debug_trap' DEBUG

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${PIPESTATUS[0]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
history() {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to builtin history (remove the --global flag)
        shift
        builtin history "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            echo "$output"
        else
            # Fall back to shell's native history, stripping clai-only flags
            local safe_args=()
            local skip_next=false
            for arg in "$@"; do
                if $skip_next; then
                    skip_next=false
                    continue
                fi
                case "$arg" in
                    --limit|--cwd|-n|--session)
                        skip_next=true
                        ;;
                    --limit=*|--cwd=*|--session=*)
                        ;;
                    *)
                        safe_args+=("$arg")
                        ;;
                esac
            done
            builtin history "${safe_args[@]}"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(builtin history 1 | sed 's/^[ ]*[0-9]*[ ]*//')}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds
    recent_cmds=$(builtin history 5 | sed 's/^[ ]*[0-9]*[ ]*//' | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}

# ============================================
# Startup Message
# ============================================

if [[ $- == *i* ]]; then
    # Use printf for better portability across bash versions
    printf '\033[2mðŸ¤– clai [%s] Tab complete | accept cmd | ?"describe task"\033[0m\n' "${CLAI_SESSION_ID:0:8}"
fi
