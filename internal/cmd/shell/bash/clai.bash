# clai.bash - clai shell integration for Bash
# Generated by: clai init bash
#
# Features:
#   1. Auto-extract suggested commands from output
#   2. Error diagnosis with `run` wrapper (captures output for analysis)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_EXTRACT=true    # Auto-extract commands (default: true)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=bash

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Feature 1: Enhanced Tab Completion
# ============================================
# Adds clai history suggestions to Tab completion menu
# Our suggestions appear first, followed by defaults

_clai_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"

    # Only enhance first word (command) completion
    if [[ $COMP_CWORD -eq 0 && -n "$cur" ]]; then
        # Get clai suggestion from history
        local suggestion=$(clai suggest "$cur" 2>/dev/null)

        # Get default command completions
        local defaults=$(compgen -c -- "$cur" 2>/dev/null | head -20)

        # Combine: clai suggestion first (if different from cur)
        if [[ -n "$suggestion" && "$suggestion" != "$cur" ]]; then
            COMPREPLY=("$suggestion" $defaults)
        else
            COMPREPLY=($defaults)
        fi

        # Deduplicate while preserving order
        COMPREPLY=($(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++'))
    else
        # For arguments, use default file completion
        COMPREPLY=($(compgen -f -- "$cur"))
    fi
}

# Register completion for common commands
# Note: complete -D (default completion) requires bash 4.0+
# For compatibility with bash 3.2 (macOS default), we register specific commands
complete -F _clai_completion git npm yarn docker kubectl make go cargo python pip

# Show AI suggestion in prompt when available (for AI-generated suggestions)
_ai_show_suggestion() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            echo -e "\033[38;5;242m($suggestion) - use 'accept' to run\033[0m"
        fi
    fi
}

# Accept AI suggestion command
accept() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            # Clear suggestion
            > "$_AI_SUGGEST_FILE"
            # Execute the suggestion
            echo -e "\033[2mRunning: $suggestion\033[0m"
            eval "$suggestion"
            return $?
        fi
    fi
    echo "No suggestion available"
    return 1
}

# Clear suggestion
clear-suggestion() {
    > "$_AI_SUGGEST_FILE"
    echo "Suggestion cleared"
}

# ============================================
# Feature 2: Prompt Hook
# ============================================

# Check result after each command
_ai_prompt_command() {
    # Show any suggestions
    _ai_show_suggestion
}

# Append to existing PROMPT_COMMAND
if [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="_ai_prompt_command"
else
    PROMPT_COMMAND="_ai_prompt_command; $PROMPT_COMMAND"
fi

# ============================================
# Feature 3: Natural Language to Command (? prefix)
# ============================================
# Lines starting with ? are treated as natural language input
# Example: ?list all files â†’ ls -la

# Check for ? prefix and convert to command
_ai_check_nl_prefix() {
    local cmd="$1"
    if [[ "$cmd" == '?'* && ${#cmd} -gt 1 ]]; then
        local nl_input="${cmd#\?}"         # Remove the ? prefix
        nl_input="${nl_input## }"          # Remove leading space if any

        echo "? $nl_input"
        local result=$(clai voice "$nl_input" 2>/dev/null)
        if [[ -n "$result" ]]; then
            echo "â†’ $result"
            # Cache for 'accept' command
            echo "$result" > "$_AI_SUGGEST_FILE"
            echo -e "\033[2mUse 'accept' to run, or copy the command above\033[0m"
        fi
        return 0  # Handled
    fi
    return 1  # Not a natural language command
}

# Hook into DEBUG trap to catch ? prefix before execution
# Note: extdebug must be enabled for the trap to block command execution
_ai_debug_trap() {
    # Check for natural language prefix first
    if _ai_check_nl_prefix "$BASH_COMMAND"; then
        # Prevent the original command from running (requires extdebug)
        return 1
    fi
    return 0
}

# Save current extdebug state and enable it for ? prefix blocking
_AI_EXTDEBUG_WAS_ON=false
if shopt -q extdebug; then
    _AI_EXTDEBUG_WAS_ON=true
fi
shopt -s extdebug

trap '_ai_debug_trap' DEBUG

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${PIPESTATUS[0]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
history() {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to builtin history (remove the --global flag)
        shift
        builtin history "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ -n "$output" && "$output" != *"No command"* ]]; then
            echo "$output"
        else
            # Fall back to shell's native history
            builtin history "$@"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(builtin history 1 | sed 's/^[ ]*[0-9]*[ ]*//')}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(builtin history 5 | sed 's/^[ ]*[0-9]*[ ]*//' | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}

# ============================================
# Startup Message
# ============================================

if [[ $- == *i* ]]; then
    # Use printf for better portability across bash versions
    printf '\033[2mðŸ¤– clai [%s] Tab complete | accept cmd | ?"describe task"\033[0m\n' "${CLAI_SESSION_ID:0:8}"
fi
