# clai.bash - clai shell integration for Bash
# Generated by: clai init bash
#
# Features:
#   1. Suggestion picker on Tab (menu-complete)
#   2. History picker on Up arrow
#   3. Error diagnosis with `run` wrapper (captures output for analysis)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_EXTRACT=true    # Auto-extract commands (default: true)

# ============================================
# Configuration
# ============================================

# Export current shell for clai doctor/status detection
export CLAI_CURRENT_SHELL=bash

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}
: ${CLAI_MENU_LIMIT:=5}
: ${CLAI_UP_ARROW_HISTORY:={{CLAI_UP_ARROW_HISTORY}}}
: ${CLAI_UP_ARROW_TRIGGER:={{CLAI_UP_ARROW_TRIGGER}}}
: ${CLAI_UP_ARROW_DOUBLE_WINDOW_MS:={{CLAI_UP_ARROW_DOUBLE_WINDOW_MS}}}

# Only initialize in interactive shells.
# This avoids installing hooks in non-interactive contexts like `bash -c` or scripts.
if [[ $- != *i* ]]; then
    return 0 2>/dev/null || exit 0
fi

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE
if [[ -z "${_CLAI_ORIG_KEYSEQ_TIMEOUT:-}" ]]; then
    _CLAI_ORIG_KEYSEQ_TIMEOUT=$(bind -v 2>/dev/null | awk '$1=="set" && $2=="keyseq-timeout" {print $3; exit}')
fi

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# Session-level disable flag
_clai_session_off() {
    [[ -f "$CLAI_CACHE/off" ]]
}

# ============================================
# Feature 1: Enhanced Tab Completion
# ============================================
# Adds clai history suggestions to Tab completion menu
# Our suggestions appear first, followed by defaults

# Portable alternative to mapfile for Bash 3.2 (macOS default)
# Usage: _clai_read_lines arrayname < <(command)
_clai_read_lines() {
    local _varname="$1"
    eval "$_varname=()"
    local _line
    while IFS= read -r _line; do
        eval "$_varname+=(\"\$_line\")"
    done
}

_clai_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"

    # Only enhance first word (command) completion
    if [[ $COMP_CWORD -eq 0 && -n "$cur" ]]; then
        local -a suggestions
        if [[ "$CLAI_OFF" != "1" ]] && ! _clai_session_off; then
            if ((BASH_VERSINFO[0] >= 4)); then
                mapfile -t suggestions < <(clai suggest --limit "$CLAI_MENU_LIMIT" "$cur" 2>/dev/null)
            else
                _clai_read_lines suggestions < <(clai suggest --limit "$CLAI_MENU_LIMIT" "$cur" 2>/dev/null)
            fi
        fi

        # Get default command completions
        local -a defaults
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t defaults < <(compgen -c -- "$cur" 2>/dev/null | head -20)
        else
            _clai_read_lines defaults < <(compgen -c -- "$cur" 2>/dev/null | head -20)
        fi

        COMPREPLY=("${suggestions[@]}" "${defaults[@]}")

        # Deduplicate while preserving order
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t COMPREPLY < <(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++')
        else
            local -a _deduped
            _clai_read_lines _deduped < <(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++')
            COMPREPLY=("${_deduped[@]}")
        fi
    else
        # For arguments, use default file completion
        if ((BASH_VERSINFO[0] >= 4)); then
            mapfile -t COMPREPLY < <(compgen -f -- "$cur")
        else
            _clai_read_lines COMPREPLY < <(compgen -f -- "$cur")
        fi
    fi
}

# Register completion for common commands
# Note: complete -D (default completion) requires bash 4.0+
_CLAI_COMMANDS=(git npm yarn docker kubectl make go cargo python pip)
if ((BASH_VERSINFO[0] >= 4)); then
    complete -o bashdefault -o default -F _clai_completion -D
else
    # For compatibility with bash 3.2 (macOS default), register specific commands
    complete -F _clai_completion "${_CLAI_COMMANDS[@]}"
fi

# Enable menu-complete cycling on Tab
bind "set show-all-if-ambiguous on"

# Tab handler: cycle history scopes when picker is active, else menu-complete.
# Uses same macro pattern as Enter: Tab â†’ macro â†’ bind-x handler â†’ conditional follow-up.
_clai_tab_handler() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        case "$_CLAI_HISTORY_SCOPE" in
            session) _CLAI_HISTORY_SCOPE="global" ;;
            *)       _CLAI_HISTORY_SCOPE="session" ;;
        esac
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
        # Swallow the follow-up so menu-complete doesn't fire
        bind '"\C-x\C-t": ""'
    else
        # Let menu-complete fire via the follow-up key
        bind '"\C-x\C-t": menu-complete'
    fi
}
bind -x '"\C-x\C-i": _clai_tab_handler'
bind '"\t": "\C-x\C-i\C-x\C-t"'

# ============================================
# Feature 1b-a: TUI Picker (clai-picker)
# ============================================
# If clai-picker is on PATH and bash supports bind -x, Up arrow and Alt+H
# open the full TUI picker.
# Exit codes: 0 = selection, 1 = cancel, 2 = fallback to native history.

_clai_has_tui_picker() {
    type -P clai-picker >/dev/null 2>&1
}

_clai_tui_picker_open() {
    if ! _clai_has_tui_picker; then
        return 2
    fi
    local result exit_code saved_line="$READLINE_LINE"
    result=$(clai-picker history --query="$READLINE_LINE" --session="$CLAI_SESSION_ID" --cwd="$PWD" 2>/dev/null)
    exit_code=$?
    if [ $exit_code -eq 0 ]; then
        READLINE_LINE="$result"
        READLINE_POINT=${#READLINE_LINE}
    elif [ $exit_code -eq 2 ]; then
        # Fall back to native history search
        return 2
    fi
    # exit_code 1 = cancel, keep original line
}

# ============================================
# Feature 1b-b: History Picker (Up Arrow)
# ============================================

_CLAI_PICKER_ACTIVE=false
_CLAI_PICKER_MODE=""
_CLAI_PICKER_INDEX=0
_CLAI_PICKER_ORIG_LINE=""
_CLAI_PICKER_ITEMS=()
_CLAI_HISTORY_SCOPE="session"
_CLAI_FALLBACK_ACTIVE=false
_CLAI_FALLBACK_INDEX=0
_CLAI_FALLBACK_ORIG_LINE=""
_CLAI_FALLBACK_ITEMS=()

_clai_fallback_reset() {
    _CLAI_FALLBACK_ACTIVE=false
    _CLAI_FALLBACK_INDEX=0
    _CLAI_FALLBACK_ORIG_LINE=""
    _CLAI_FALLBACK_ITEMS=()
}

_clai_fallback_load_history() {
    local -a entries
    if ((BASH_VERSINFO[0] >= 4)); then
        mapfile -t entries < <(history | sed -E 's/^ *[0-9]+[[:space:]]+//')
    else
        _clai_read_lines entries < <(history | sed -E 's/^ *[0-9]+[[:space:]]+//')
    fi

    _CLAI_FALLBACK_ITEMS=()
    local entry
    for entry in "${entries[@]}"; do
        if [[ -n "$entry" ]]; then
            _CLAI_FALLBACK_ITEMS+=("$entry")
        fi
    done

    if [[ ${#_CLAI_FALLBACK_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    return 0
}

_clai_fallback_apply() {
    local selected="${_CLAI_FALLBACK_ITEMS[$_CLAI_FALLBACK_INDEX]}"
    if [[ -n "$selected" ]]; then
        READLINE_LINE="$selected"
        READLINE_POINT=${#READLINE_LINE}
    fi
}

_clai_fallback_history_up() {
    if [[ "$_CLAI_FALLBACK_ACTIVE" != "true" ]]; then
        if ! _clai_fallback_load_history; then
            return 0
        fi
        _CLAI_FALLBACK_ORIG_LINE="$READLINE_LINE"
        _CLAI_FALLBACK_INDEX=$((${#_CLAI_FALLBACK_ITEMS[@]} - 1))
        _CLAI_FALLBACK_ACTIVE=true
        _clai_fallback_apply
        return 0
    fi

    if [[ $_CLAI_FALLBACK_INDEX -gt 0 ]]; then
        ((_CLAI_FALLBACK_INDEX--))
    else
        _CLAI_FALLBACK_INDEX=0
    fi
    _clai_fallback_apply
}

_clai_fallback_history_down() {
    if [[ "$_CLAI_FALLBACK_ACTIVE" != "true" ]]; then
        return 0
    fi

    if [[ $_CLAI_FALLBACK_INDEX -lt $((${#_CLAI_FALLBACK_ITEMS[@]} - 1)) ]]; then
        ((_CLAI_FALLBACK_INDEX++))
        _clai_fallback_apply
        return 0
    fi

    READLINE_LINE="$_CLAI_FALLBACK_ORIG_LINE"
    READLINE_POINT=${#READLINE_LINE}
    _clai_fallback_reset
}

_clai_history_args() {
    # Each argument on its own line so newline-based splitting works
    # correctly even when $PWD contains spaces.
    case "$_CLAI_HISTORY_SCOPE" in
        session)
            echo "--session=$CLAI_SESSION_ID"
            ;;
        cwd)
            echo "--session=$CLAI_SESSION_ID"
            echo "--cwd=$PWD"
            ;;
        global)
            echo "--global"
            ;;
        *)
            echo "--session=$CLAI_SESSION_ID"
            ;;
    esac
}

_clai_picker_load_history() {
    local -a args raw
    local IFS=$'\n'
    args=($(_clai_history_args))
    unset IFS
    if ((BASH_VERSINFO[0] >= 4)); then
        mapfile -t raw < <(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" "$READLINE_LINE" 2>/dev/null)
    else
        _clai_read_lines raw < <(clai history "${args[@]}" --limit "$CLAI_MENU_LIMIT" "$READLINE_LINE" 2>/dev/null)
    fi
    # Deduplicate preserving order
    if ((BASH_VERSINFO[0] >= 4)); then
        mapfile -t _CLAI_PICKER_ITEMS < <(printf '%s\n' "${raw[@]}" | awk '!seen[$0]++')
    else
        _clai_read_lines _CLAI_PICKER_ITEMS < <(printf '%s\n' "${raw[@]}" | awk '!seen[$0]++')
    fi
    if [[ ${#_CLAI_PICKER_ITEMS[@]} -eq 0 ]]; then
        return 1
    fi
    return 0
}

_CLAI_PICKER_LINE_COUNT=0

_clai_picker_render() {
    local header="Suggestions"
    if [[ "$_CLAI_PICKER_MODE" == "history" ]]; then
        header="History (${_CLAI_HISTORY_SCOPE})"
    fi

    local menu_text="$header (â†‘â†“, Enter, Ctrl+G):"
    menu_text+=$'\n'"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    local i=0
    local line_count=2
    for item in "${_CLAI_PICKER_ITEMS[@]}"; do
        if [[ $i -eq $_CLAI_PICKER_INDEX ]]; then
            menu_text+=$'\n'" â†’ $item"
        else
            menu_text+=$'\n'"   $item"
        fi
        ((i++))
        ((line_count++))
    done

    _CLAI_PICKER_LINE_COUNT=$line_count

    # Draw below command line using terminal escape sequences
    printf '\e[s' >&2              # save cursor position
    printf '\n\e[J' >&2            # newline + clear to end of screen
    printf '%s\n' "$menu_text" >&2
    printf '\e[u' >&2              # restore cursor position
}

_clai_picker_clear_menu() {
    if [[ $_CLAI_PICKER_LINE_COUNT -gt 0 ]]; then
        printf '\e[s' >&2          # save cursor
        printf '\n\e[J' >&2        # newline + clear to end of screen
        printf '\e[u' >&2          # restore cursor
        _CLAI_PICKER_LINE_COUNT=0
    fi
}

_clai_picker_apply() {
    local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX]}"
    if [[ -n "$selected" ]]; then
        READLINE_LINE="$selected"
        READLINE_POINT=${#READLINE_LINE}
    fi
    _clai_picker_render
}

_clai_history_up() {
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
            _clai_picker_cancel
        fi
        _clai_fallback_history_up
        return 0
    fi
    # Try TUI picker first (when inline picker is not already active)
    if [[ "$_CLAI_PICKER_ACTIVE" != "true" ]] && _clai_has_tui_picker; then
        _clai_tui_picker_open
        return 0
    fi
    if [[ "$_CLAI_FALLBACK_ACTIVE" == "true" ]]; then
        _clai_fallback_reset
    fi
    if [[ "$_CLAI_PICKER_ACTIVE" != "true" || "$_CLAI_PICKER_MODE" != "history" ]]; then
        _CLAI_PICKER_ORIG_LINE="$READLINE_LINE"
        _CLAI_PICKER_MODE="history"
        _CLAI_PICKER_INDEX=0
        _CLAI_PICKER_ACTIVE=true
        # Install Enter macro so picker can intercept it
        bind '"\C-m": "\C-x\C-a\C-x\C-b"'
        if ! _clai_picker_load_history; then
            _CLAI_PICKER_ACTIVE=false
            bind '"\C-m": accept-line'
            return 0
        fi
        _clai_picker_apply
        return 0
    fi

    if [[ $_CLAI_PICKER_INDEX -lt $((${#_CLAI_PICKER_ITEMS[@]} - 1)) ]]; then
        ((_CLAI_PICKER_INDEX++))
    else
        _CLAI_PICKER_INDEX=0
    fi
    _clai_picker_apply
}

_clai_history_down() {
    if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
        if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
            _clai_picker_cancel
        fi
        _clai_fallback_history_down
        return 0
    fi
    if [[ "$_CLAI_FALLBACK_ACTIVE" == "true" ]]; then
        _clai_fallback_reset
    fi
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        if [[ $_CLAI_PICKER_INDEX -gt 0 ]]; then
            ((_CLAI_PICKER_INDEX--))
        else
            _CLAI_PICKER_INDEX=$((${#_CLAI_PICKER_ITEMS[@]} - 1))
        fi
        _clai_picker_apply
    fi
}

_clai_picker_close() {
    _clai_picker_clear_menu
    _CLAI_PICKER_ACTIVE=false
    _CLAI_PICKER_MODE=""
    _CLAI_PICKER_ITEMS=()
    _CLAI_PICKER_INDEX=0
    # Restore normal Enter (remove macro that routes through bind -x)
    bind '"\C-m": accept-line'
}

_clai_picker_cancel() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        READLINE_LINE="$_CLAI_PICKER_ORIG_LINE"
        READLINE_POINT=${#READLINE_LINE}
        _clai_picker_close
    fi
}

# Enter key handler: accept picker selection when active.
# Only reached when the picker is open (macro installed by _clai_history_up).
# The macro "\C-x\C-a\C-x\C-b" calls this via bind -x, then \C-x\C-b fires.
_clai_pre_accept() {
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" ]]; then
        # Record accepted feedback for picker selection (fire and forget)
        local selected="${_CLAI_PICKER_ITEMS[$_CLAI_PICKER_INDEX]}"
        if [[ -n "$selected" ]]; then
            (clai suggest-feedback --action=accepted --suggested="$selected" >/dev/null 2>&1 &)
        fi
        # Accept the current selection and close the picker
        _clai_picker_close
        # Swallow the accept-line that follows in the macro
        bind '"\C-x\C-b": ""'
    else
        # Shouldn't normally be reached, but handle gracefully
        bind '"\C-x\C-b": accept-line'
    fi
}

_clai_history_scope_session() {
    _CLAI_HISTORY_SCOPE="session"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

_clai_history_scope_cwd() {
    _CLAI_HISTORY_SCOPE="cwd"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

_clai_history_scope_global() {
    _CLAI_HISTORY_SCOPE="global"
    if [[ "$_CLAI_PICKER_ACTIVE" == "true" && "$_CLAI_PICKER_MODE" == "history" ]]; then
        _CLAI_PICKER_INDEX=0
        _clai_picker_load_history && _clai_picker_apply
    fi
}

# Bindings: Up/Down for history picker, Enter accepts, Ctrl+G cancels,
# Ctrl+x s/d/g switches scope.
#
# Arrow keys: bash 3.2 (macOS default) doesn't support `bind -x` with escape
# sequences â€” it fails with "cannot find keymap for command". Work around by
# using a readline macro to translate arrow escapes to Ctrl-X prefixed
# sequences, then bind those with -x.
# Alt/Option+H opens TUI picker.
# '\eh' works when the terminal sends ESC for Alt (Linux, macOS with Meta key).
# On macOS, Option+H produces Ë™ (U+02D9). bash 3.2 cannot bind -x to multi-byte
# chars, so we use a macro to translate it to a Ctrl sequence we can bind -x to.
bind -x '"\eh": _clai_tui_picker_open'
bind -x '"\C-x\C-h": _clai_tui_picker_open'
bind '"Ë™": "\C-x\C-h"'

# When up_arrow_opens_history is enabled:
# - trigger=single: Up opens TUI picker (fallback: native history)
# - trigger=double: Up uses native history; Up+Up within window opens picker.
if [[ "$CLAI_UP_ARROW_HISTORY" == "true" ]]; then
    _clai_up_arrow_single() {
        if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
            bind '"\C-x\C-q": previous-history'
            return 0
        fi

        if [[ "${CLAI_UP_ARROW_TRIGGER:-single}" == "double" ]]; then
            bind '"\C-x\C-q": previous-history'
            return 0
        fi

        if _clai_has_tui_picker; then
            bind '"\C-x\C-q": ""'
            _clai_tui_picker_open
            return 0
        fi
        bind '"\C-x\C-q": previous-history'
        return 0
    }

    _clai_up_arrow_double() {
        if [[ "$CLAI_OFF" == "1" ]] || _clai_session_off; then
            _clai_fallback_history_up
            _clai_fallback_history_up
            return 0
        fi

        if _clai_has_tui_picker; then
            _clai_tui_picker_open
            return 0
        fi
        _clai_fallback_history_up
        _clai_fallback_history_up
        return 0
    }

    bind -x '"\C-x\C-p": _clai_up_arrow_single'
    bind -x '"\C-x\C-u": _clai_up_arrow_double'

    if [[ "${CLAI_UP_ARROW_TRIGGER:-single}" == "double" ]]; then
        _clai_keyseq_timeout="${CLAI_UP_ARROW_DOUBLE_WINDOW_MS:-250}"
        if [[ ! "$_clai_keyseq_timeout" =~ ^[0-9]+$ ]]; then
            _clai_keyseq_timeout=250
        fi
        if [[ "$_clai_keyseq_timeout" -lt 50 ]]; then
            _clai_keyseq_timeout=50
        fi
        if [[ "$_clai_keyseq_timeout" -gt 1000 ]]; then
            _clai_keyseq_timeout=1000
        fi
        bind "set keyseq-timeout ${_clai_keyseq_timeout}"
        bind '"\e[A": previous-history'
        bind '"\eOA": previous-history'
        bind '"\e[A\e[A": "\C-x\C-u"'
        bind '"\eOA\eOA": "\C-x\C-u"'
    else
        bind -r '\e[A\e[A' 2>/dev/null
        bind -r '\eOA\eOA' 2>/dev/null
        bind '"\e[A": "\C-x\C-p\C-x\C-q"'
        bind '"\eOA": "\C-x\C-p\C-x\C-q"'
    fi
fi

# Show AI suggestion in prompt when available (for AI-generated suggestions)
_ai_show_suggestion() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion
        suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            echo -e "\033[38;5;242m($suggestion) - use 'accept' to run\033[0m"
        fi
    fi
}

# Accept AI suggestion command
accept() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            # Record accepted feedback (fire and forget)
            (clai suggest-feedback --action=accepted --suggested="$suggestion" >/dev/null 2>&1 &)
            # Clear suggestion
            > "$_AI_SUGGEST_FILE"
            # Execute the suggestion
            echo -e "\033[2mRunning: $suggestion\033[0m"
            eval "$suggestion"
            return $?
        fi
    fi
    echo "No suggestion available"
    return 1
}

# Clear suggestion (dismiss)
clear-suggestion() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            # Record dismissed feedback (fire and forget)
            (clai suggest-feedback --action=dismissed --suggested="$suggestion" >/dev/null 2>&1 &)
        fi
    fi
    > "$_AI_SUGGEST_FILE"
    echo "Suggestion cleared"
}

# ============================================
# Feature 2: Command Logging Hooks
# ============================================
# Log commands for session history (enables clai history)
# Uses DEBUG trap for preexec (command start) and PROMPT_COMMAND for precmd (command end)
#
# Key challenge: Bash's DEBUG trap fires for EVERY command including those inside
# functions and PROMPT_COMMAND. We detect user commands by checking BASH_COMMAND
# against internal patterns and using FUNCNAME to detect function context.

# Command tracking state
_CLAI_COMMAND_ID=""
_CLAI_COMMAND_START_TIME=""
_CLAI_LAST_COMMAND=""
_CLAI_PENDING_LOG=false  # True when we have a command to log on completion

# Log command start (called from DEBUG trap before command execution)
_clai_log_command_start() {
    local cmd="$1"

    # Skip empty commands
    [[ -z "$cmd" ]] && return 1

    # Skip if we're inside a function (FUNCNAME has entries beyond main)
    # FUNCNAME[0] is this function, FUNCNAME[1] is caller
    # For top-level commands, FUNCNAME should be small
    if [[ ${#FUNCNAME[@]} -gt 2 ]]; then
        return 1
    fi

    # Skip internal clai functions and common shell patterns
    case "$cmd" in
        _ai_*|_clai_*|_AI_*|_CLAI_*) return 1 ;;
        '['*|'[['*|'(('*) return 1 ;;  # Test expressions
        local\ *|export\ *|return\ *|declare\ *|unset\ *|shift*|readonly\ *|typeset\ *|set\ *) return 1 ;;
    esac

    # Skip if already tracking a command
    [[ "$_CLAI_PENDING_LOG" == "true" ]] && return 1

    # Mark that we have a pending command to log
    _CLAI_PENDING_LOG=true

    # Generate unique command ID
    _CLAI_COMMAND_ID="${CLAI_SESSION_ID}-$(date +%s)-${RANDOM}"
    # Store start time in milliseconds. Use nanoseconds if available (GNU coreutils).
    if date +%s%N >/dev/null 2>&1; then
        _CLAI_COMMAND_START_TIME=$(($(date +%s%N) / 1000000))
    else
        _CLAI_COMMAND_START_TIME=$(($(date +%s) * 1000))
    fi
    _CLAI_LAST_COMMAND="$cmd"

    # Fire and forget - log command start to daemon
    (clai-shim log-start \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --cwd="$PWD" \
        --command="$cmd" >/dev/null 2>&1 &)

    return 0
}

# Log command end (called from PROMPT_COMMAND after command execution)
_clai_log_command_end() {
    local exit_code="$1"

    # Only log if we have a pending command
    [[ "$_CLAI_PENDING_LOG" != "true" ]] && return
    [[ -z "$_CLAI_COMMAND_ID" ]] && return

    # Calculate end time in milliseconds. Use nanoseconds if available (GNU coreutils).
    local end_time
    if date +%s%N >/dev/null 2>&1; then
        end_time=$(($(date +%s%N) / 1000000))
    else
        end_time=$(($(date +%s) * 1000))
    fi
    local duration=$((end_time - _CLAI_COMMAND_START_TIME))

    # Fire and forget - log command end to daemon
    (clai-shim log-end \
        --session-id="$CLAI_SESSION_ID" \
        --command-id="$_CLAI_COMMAND_ID" \
        --exit-code="$exit_code" \
        --duration="$duration" >/dev/null 2>&1 &)

    # Clear command tracking state
    _CLAI_COMMAND_ID=""
    _CLAI_COMMAND_START_TIME=""
    _CLAI_PENDING_LOG=false
}

# Prompt command hook (runs after each command, before showing prompt)
_ai_prompt_command() {
    local last_exit=$?

    # Log command completion (only if we ran a user command)
    _clai_log_command_end "$last_exit"

    # Show any suggestions
    _ai_show_suggestion
}

# Append to existing PROMPT_COMMAND
if [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="_ai_prompt_command"
else
    PROMPT_COMMAND="_ai_prompt_command; $PROMPT_COMMAND"
fi

# ============================================
# Feature 3: Natural Language to Command (? prefix)
# ============================================
# Lines starting with ? are treated as natural language input
# Example: ?list all files â†’ ls -la

# Check for ? prefix and convert to command
_ai_check_nl_prefix() {
    local cmd="$1"
    if [[ "$cmd" == '?'* && ${#cmd} -gt 1 ]]; then
        local nl_input="${cmd#\?}"         # Remove the ? prefix
        nl_input="${nl_input## }"          # Remove leading space if any

        echo "? $nl_input"
        local result
        result=$(clai voice "$nl_input" 2>/dev/null)
        if [[ -n "$result" ]]; then
            echo "â†’ $result"
            # Cache for 'accept' command
            echo "$result" > "$_AI_SUGGEST_FILE"
            echo -e "\033[2mUse 'accept' to run, or copy the command above\033[0m"
        fi
        return 0  # Handled
    fi
    return 1  # Not a natural language command
}

# Hook into DEBUG trap to catch ? prefix before execution and log commands
# Note: extdebug must be enabled for the trap to block command execution
_ai_debug_trap() {
    # Check for natural language prefix first
    if _ai_check_nl_prefix "$BASH_COMMAND"; then
        # Prevent the original command from running (requires extdebug)
        return 1
    fi

    # Log command start (for session history)
    _clai_log_command_start "$BASH_COMMAND"

    return 0
}

# Save current extdebug state and enable it for ? prefix blocking.
# Side effects: extdebug causes DEBUG/RETURN/ERR traps to be inherited by
# shell functions, command substitutions, and subshells. This is required
# for the ? prefix interception (returning 1 from DEBUG trap skips the
# command). The original state is saved and restored in _clai_cleanup.
_AI_EXTDEBUG_WAS_ON=false
if shopt -q extdebug; then
    _AI_EXTDEBUG_WAS_ON=true
fi
shopt -s extdebug

trap '_ai_debug_trap' DEBUG

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${PIPESTATUS[0]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Session Tracking
# ============================================
# Session ID for this shell instance (generated by clai init)
export CLAI_SESSION_ID="{{CLAI_SESSION_ID}}"

# ============================================
# Manual Commands
# ============================================

# Intercept history command to show session-specific history
# Falls back to shell history if no session history available
# Use `history --global` or `history -g` for shell-native history
history() {
    if [[ "$1" == "--global" || "$1" == "-g" ]]; then
        # Pass through to builtin history (remove the --global flag)
        shift
        builtin history "$@"
    elif [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "Usage: history [options] [query]"
        echo ""
        echo "Shows command history (session-specific if available, else shell history)."
        echo ""
        echo "Options:"
        echo "  -g, --global    Always use shell's native history"
        echo "  -n, --limit N   Maximum number of commands to show (default: 20)"
        echo "  --cwd PATH      Filter by working directory"
        echo ""
        echo "Examples:"
        echo "  history              # Show session or shell history"
        echo "  history git          # Filter to git commands"
        echo "  history --global     # Force shell's native history"
    else
        # Try clai session history first, fall back to shell history
        local output
        output=$(clai history --session="$CLAI_SESSION_ID" "$@" 2>/dev/null)
        if [[ $? -eq 0 && -n "$output" ]]; then
            echo "$output"
        else
            # Fall back to shell's native history, stripping clai-only flags
            local safe_args=()
            local skip_next=false
            for arg in "$@"; do
                if $skip_next; then
                    skip_next=false
                    continue
                fi
                case "$arg" in
                    --limit|--cwd|-n|--session)
                        skip_next=true
                        ;;
                    --limit=*|--cwd=*|--session=*)
                        ;;
                    *)
                        safe_args+=("$arg")
                        ;;
                esac
            done
            builtin history "${safe_args[@]}"
        fi
    fi
}

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(builtin history 1 | sed 's/^[ ]*[0-9]*[ ]*//')}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds
    recent_cmds=$(builtin history 5 | sed 's/^[ ]*[0-9]*[ ]*//' | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}

# ============================================
# Full Disable / Enable (clai off / clai on)
# ============================================

_clai_disable() {
    export CLAI_OFF=1

    # Restore default keybindings
    bind '"\C-m": accept-line'
    bind '"\e[A": previous-history'
    bind '"\eOA": previous-history'
    bind '"\e[B": next-history'
    bind '"\t": complete'
    bind "set show-all-if-ambiguous off"
    bind -r '\e[A\e[A' 2>/dev/null
    bind -r '\eOA\eOA' 2>/dev/null
    if [[ -n "$_CLAI_ORIG_KEYSEQ_TIMEOUT" ]]; then
        bind "set keyseq-timeout ${_CLAI_ORIG_KEYSEQ_TIMEOUT}"
    fi

    # Remove custom key bindings
    bind -r '\C-x\C-a'
    bind -r '\C-x\C-b'
    bind -r '\C-x\C-i'
    bind -r '\C-x\C-t'
    bind -r '\C-x\C-p'
    bind -r '\C-x\C-u'
    bind -r '\C-x\C-q'
    bind -r '\C-x\C-n'
    bind -r '\C-g'
    bind -r '\C-xs'
    bind -r '\C-xd'
    bind -r '\C-xg'
    bind -r '\eh'
    bind -r '\C-x\C-h'
    bind -r 'Ë™'

    # Remove completion handlers (default + per-command for bash <4)
    complete -r -D 2>/dev/null
    for _cmd in "${_CLAI_COMMANDS[@]}"; do
        complete -r "$_cmd" 2>/dev/null
    done

    # Strip _ai_prompt_command from PROMPT_COMMAND
    PROMPT_COMMAND="${PROMPT_COMMAND//_ai_prompt_command;/}"
    PROMPT_COMMAND="${PROMPT_COMMAND//_ai_prompt_command/}"

    # Remove DEBUG trap and restore extdebug
    trap - DEBUG
    if [[ "$_AI_EXTDEBUG_WAS_ON" != "true" ]]; then
        shopt -u extdebug
    fi

    # Restore native history command
    unset -f history 2>/dev/null

    echo "clai disabled â€” native shell restored"
}

_clai_enable() {
    unset CLAI_OFF
    local _saved_session="$CLAI_SESSION_ID"
    _CLAI_REINIT=1
    eval "$(command clai init bash)"
    unset _CLAI_REINIT
    # Preserve original session ID so history stays continuous
    export CLAI_SESSION_ID="$_saved_session"
    echo "clai enabled"
}

# Wrapper function: intercepts off/on to run shell-native disable/enable
clai() {
    case "$1" in
        off)
            command clai "$@"
            _clai_disable
            ;;
        on)
            command clai "$@"
            _clai_enable
            ;;
        *)
            command clai "$@"
            ;;
    esac
}

# ============================================
# Startup Message
# ============================================

if [[ $- == *i* && -z "$_CLAI_REINIT" ]]; then
    # Register session with daemon (fire and forget)
    # This notifies the daemon of the new shell session
    (clai-shim session-start \
        --session-id="$CLAI_SESSION_ID" \
        --cwd="$PWD" \
        --shell="$CLAI_CURRENT_SHELL" >/dev/null 2>&1 &)

    # Import shell history on first init (fire and forget)
    # This is idempotent: --if-not-exists skips if already imported
    (clai-shim import-history \
        --shell="$CLAI_CURRENT_SHELL" \
        --if-not-exists >/dev/null 2>&1 &)

    # Use printf for better portability across bash versions
    printf '\033[2mðŸ¤– clai [%s] Tab complete | accept cmd | ?"describe task"\033[0m\n' "${CLAI_SESSION_ID:0:8}"
fi
