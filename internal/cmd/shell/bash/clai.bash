# clai.bash - clai shell integration for Bash
# Generated by: clai init bash
#
# Features:
#   1. Auto-extract suggested commands from output
#   2. Error diagnosis with `run` wrapper (captures output for analysis)
#
# Configuration (set these BEFORE sourcing):
#   CLAI_AUTO_EXTRACT=true    # Auto-extract commands (default: true)

# ============================================
# Configuration
# ============================================

: ${CLAI_AUTO_EXTRACT:=true}
: ${CLAI_CACHE:="$HOME/.cache/clai"}

# Ensure cache directory exists
mkdir -p "$CLAI_CACHE"

# Export for child processes
export CLAI_CACHE

# Files
_AI_SUGGEST_FILE="$CLAI_CACHE/suggestion"
_AI_LAST_OUTPUT="$CLAI_CACHE/last_output"

# ============================================
# Feature 1: Enhanced Tab Completion
# ============================================
# Adds clai history suggestions to Tab completion menu
# Our suggestions appear first, followed by defaults

_clai_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"

    # Only enhance first word (command) completion
    if [[ $COMP_CWORD -eq 0 && -n "$cur" ]]; then
        # Get clai suggestion from history
        local suggestion=$(clai suggest "$cur" 2>/dev/null)

        # Get default command completions
        local defaults=$(compgen -c -- "$cur" 2>/dev/null | head -20)

        # Combine: clai suggestion first (if different from cur)
        if [[ -n "$suggestion" && "$suggestion" != "$cur" ]]; then
            COMPREPLY=("$suggestion" $defaults)
        else
            COMPREPLY=($defaults)
        fi

        # Deduplicate while preserving order
        COMPREPLY=($(printf '%s\n' "${COMPREPLY[@]}" | awk '!seen[$0]++'))
    else
        # For arguments, use default file completion
        COMPREPLY=($(compgen -f -- "$cur"))
    fi
}

# Register as default completion for commands
complete -D -F _clai_completion

# Also register for specific common commands to ensure it's used
complete -F _clai_completion git npm yarn docker kubectl

# Show AI suggestion in prompt when available (for AI-generated suggestions)
_ai_show_suggestion() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            echo -e "\033[38;5;242m($suggestion) - use 'accept' to run\033[0m"
        fi
    fi
}

# Accept AI suggestion command
accept() {
    if [[ -s "$_AI_SUGGEST_FILE" ]]; then
        local suggestion=$(cat "$_AI_SUGGEST_FILE")
        if [[ -n "$suggestion" ]]; then
            # Clear suggestion
            > "$_AI_SUGGEST_FILE"
            # Execute the suggestion
            echo -e "\033[2mRunning: $suggestion\033[0m"
            eval "$suggestion"
            return $?
        fi
    fi
    echo "No suggestion available"
    return 1
}

# Clear suggestion
clear-suggestion() {
    > "$_AI_SUGGEST_FILE"
    echo "Suggestion cleared"
}

# ============================================
# Feature 2: Prompt Hook
# ============================================

# Check result after each command
_ai_prompt_command() {
    # Show any suggestions
    _ai_show_suggestion
}

# Append to existing PROMPT_COMMAND
if [[ -z "$PROMPT_COMMAND" ]]; then
    PROMPT_COMMAND="_ai_prompt_command"
else
    PROMPT_COMMAND="_ai_prompt_command; $PROMPT_COMMAND"
fi

# ============================================
# Feature 3: Voice Mode (` prefix)
# ============================================
# Lines starting with ` are treated as voice/natural language input
# Example: `list all files â†’ ls -la

# Check for ` prefix and convert voice input
_ai_check_voice_prefix() {
    local cmd="$1"
    if [[ "$cmd" == '`'* && ${#cmd} -gt 1 ]]; then
        local voice_input="${cmd#\`}"      # Remove the ` prefix
        voice_input="${voice_input## }"    # Remove leading space if any

        echo "ðŸŽ¤ Converting: $voice_input"
        local result=$(clai voice "$voice_input" 2>/dev/null)
        if [[ -n "$result" ]]; then
            echo "â†’ $result"
            # Cache for 'accept' command
            echo "$result" > "$_AI_SUGGEST_FILE"
            echo -e "\033[2mUse 'accept' to run, or copy the command above\033[0m"
        fi
        return 0  # Handled
    fi
    return 1  # Not a voice command
}

# Hook into DEBUG trap to catch ` prefix before execution
# Note: extdebug must be enabled for the trap to block command execution
_ai_debug_trap() {
    # Check for voice prefix first
    if _ai_check_voice_prefix "$BASH_COMMAND"; then
        # Prevent the original command from running (requires extdebug)
        return 1
    fi
    return 0
}

# Save current extdebug state and enable it for voice prefix blocking
_AI_EXTDEBUG_WAS_ON=false
if shopt -q extdebug; then
    _AI_EXTDEBUG_WAS_ON=true
fi
shopt -s extdebug

trap '_ai_debug_trap' DEBUG

# ============================================
# Output Capture (via wrapper function)
# ============================================

# Wrap command execution to capture output and auto-diagnose on failure
# Usage: run <command> - captures output, extracts suggestions, diagnoses errors
run() {
    # Run command, capture output, pass through clai extract
    "$@" 2>&1 | clai extract
    local exit_code=${PIPESTATUS[0]}

    # Auto-diagnose if command failed
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        echo -e "\033[38;5;214mâš¡ Analyzing error...\033[0m"
        clai diagnose "$*" "$exit_code" 2>/dev/null
    fi

    return $exit_code
}

# ============================================
# Manual Commands
# ============================================

# Manually diagnose last command
ai-fix() {
    local cmd="${1:-$(history 1 | sed 's/^[ ]*[0-9]*[ ]*//')}"
    clai diagnose "$cmd" "1"
}

# Ask Claude anything with terminal context
ai() {
    if [[ -z "$1" ]]; then
        echo "Usage: ai \"your question\""
        return 1
    fi

    local recent_cmds=$(history 5 | sed 's/^[ ]*[0-9]*[ ]*//' | tr '\n' ';')
    clai ask --context "$recent_cmds" "$@"
}

# Convert voice/natural language to terminal command
voice() {
    if [[ -z "$1" ]]; then
        echo "Usage: voice \"natural language description\""
        return 1
    fi

    clai voice "$@"
}

# ============================================
# Startup Message
# ============================================

if [[ $- == *i* ]]; then
    echo -e "\033[2mðŸ¤– clai loaded. Commands: ai-fix, ai, voice, run, accept | \` prefix for voice mode\033[0m"
fi
